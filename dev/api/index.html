<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · SelfPropelledVoronoi</title><meta name="title" content="API Reference · SelfPropelledVoronoi"/><meta property="og:title" content="API Reference · SelfPropelledVoronoi"/><meta property="twitter:title" content="API Reference · SelfPropelledVoronoi"/><meta name="description" content="Documentation for SelfPropelledVoronoi."/><meta property="og:description" content="Documentation for SelfPropelledVoronoi."/><meta property="twitter:description" content="Documentation for SelfPropelledVoronoi."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SelfPropelledVoronoi</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../overview/">Overview</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li class="is-active"><a class="tocitem" href>API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/IlianPihlajamaa/SelfPropelledVoronoi.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/IlianPihlajamaa/SelfPropelledVoronoi.jl/blob/master/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><ul><li><a href="#SelfPropelledVoronoi.ArrayStruct"><code>SelfPropelledVoronoi.ArrayStruct</code></a></li><li><a href="#SelfPropelledVoronoi.DumpInfo"><code>SelfPropelledVoronoi.DumpInfo</code></a></li><li><a href="#SelfPropelledVoronoi.Output"><code>SelfPropelledVoronoi.Output</code></a></li><li><a href="#SelfPropelledVoronoi.ParameterStruct"><code>SelfPropelledVoronoi.ParameterStruct</code></a></li><li><a href="#SelfPropelledVoronoi.SimulationBox"><code>SelfPropelledVoronoi.SimulationBox</code></a></li><li><a href="#SelfPropelledVoronoi.VoronoiCells"><code>SelfPropelledVoronoi.VoronoiCells</code></a></li><li><a href="#SelfPropelledVoronoi.VoronoiNeighborList"><code>SelfPropelledVoronoi.VoronoiNeighborList</code></a></li><li><a href="#SelfPropelledVoronoi.apply_periodic_boundary_conditions-Tuple{Any, Any}"><code>SelfPropelledVoronoi.apply_periodic_boundary_conditions</code></a></li><li><a href="#SelfPropelledVoronoi.circumcenter-Union{Tuple{T}, Tuple{StaticArraysCore.SVector{2, T}, StaticArraysCore.SVector{2, T}, StaticArraysCore.SVector{2, T}}} where T"><code>SelfPropelledVoronoi.circumcenter</code></a></li><li><a href="#SelfPropelledVoronoi.compute_energy-Tuple{Any, Any, Any}"><code>SelfPropelledVoronoi.compute_energy</code></a></li><li><a href="#SelfPropelledVoronoi.compute_energy_i-NTuple{4, Any}"><code>SelfPropelledVoronoi.compute_energy_i</code></a></li><li><a href="#SelfPropelledVoronoi.compute_forces_GCM!-Tuple{Any, Any, Any}"><code>SelfPropelledVoronoi.compute_forces_GCM!</code></a></li><li><a href="#SelfPropelledVoronoi.compute_forces_SPV!-Tuple{Any, Any, Any}"><code>SelfPropelledVoronoi.compute_forces_SPV!</code></a></li><li><a href="#SelfPropelledVoronoi.compute_pair_distance_vector-Tuple{Any, Any, Any}"><code>SelfPropelledVoronoi.compute_pair_distance_vector</code></a></li><li><a href="#SelfPropelledVoronoi.do_time_step-Tuple{Any, Any, Any}"><code>SelfPropelledVoronoi.do_time_step</code></a></li><li><a href="#SelfPropelledVoronoi.do_time_step_Euler_Heun!-Tuple{Any, Any, Any}"><code>SelfPropelledVoronoi.do_time_step_Euler_Heun!</code></a></li><li><a href="#SelfPropelledVoronoi.do_time_step_Euler_Murayama-Tuple{Any, Any, Any}"><code>SelfPropelledVoronoi.do_time_step_Euler_Murayama</code></a></li><li><a href="#SelfPropelledVoronoi.norm2-Union{Tuple{StaticArraysCore.SVector{2, T}}, Tuple{T}} where T"><code>SelfPropelledVoronoi.norm2</code></a></li><li><a href="#SelfPropelledVoronoi.replace_or_push!-Tuple{Any, Any, Any}"><code>SelfPropelledVoronoi.replace_or_push!</code></a></li><li><a href="#SelfPropelledVoronoi.run_simulation!-NTuple{4, Any}"><code>SelfPropelledVoronoi.run_simulation!</code></a></li><li><a href="#SelfPropelledVoronoi.save_simulation_state!-Tuple{ParameterStruct, ArrayStruct, Output}"><code>SelfPropelledVoronoi.save_simulation_state!</code></a></li><li><a href="#SelfPropelledVoronoi.sort_indices_counter_clockwise-NTuple{4, Any}"><code>SelfPropelledVoronoi.sort_indices_counter_clockwise</code></a></li><li><a href="#SelfPropelledVoronoi.update_areas!-Tuple{Any, Any, Any}"><code>SelfPropelledVoronoi.update_areas!</code></a></li><li><a href="#SelfPropelledVoronoi.update_perimeters!-Tuple{Any, Any, Any}"><code>SelfPropelledVoronoi.update_perimeters!</code></a></li><li><a href="#SelfPropelledVoronoi.update_positions_with_pbcs!-Tuple{Any, Any, Any}"><code>SelfPropelledVoronoi.update_positions_with_pbcs!</code></a></li><li><a href="#SelfPropelledVoronoi.update_voronoi_vertices!-NTuple{4, Any}"><code>SelfPropelledVoronoi.update_voronoi_vertices!</code></a></li><li><a href="#SelfPropelledVoronoi.verify_tessellation-Tuple{Any, Any, Any}"><code>SelfPropelledVoronoi.verify_tessellation</code></a></li><li><a href="#SelfPropelledVoronoi.voronoi_tesselation!-Tuple{Any, Any, Any}"><code>SelfPropelledVoronoi.voronoi_tesselation!</code></a></li><li><a href="#SelfPropelledVoronoi.when_to_print_array-Tuple{Any}"><code>SelfPropelledVoronoi.when_to_print_array</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SelfPropelledVoronoi.ArrayStruct" href="#SelfPropelledVoronoi.ArrayStruct"><code>SelfPropelledVoronoi.ArrayStruct</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ArrayStruct(N)</code></pre><p>A structure that holds various arrays for storing particle properties and the simulation state. These arrays are typically updated at each time step of the simulation. The type parameter <code>NB</code> refers to the type of the neighbor list structure used (e.g., <code>VoronoiNeighborList</code>).</p><p><strong>Fields</strong></p><ul><li><code>positions::Vector{SVector{2, Float64}}</code>: Current 2D positions of all particles.</li><li><code>old_positions::Vector{SVector{2, Float64}}</code>: Positions of all particles at the previous time step. Used for some integration schemes or state tracking.</li><li><code>forces::Vector{SVector{2, Float64}}</code>: Current 2D forces acting on all particles.</li><li><code>old_forces::Vector{SVector{2, Float64}}</code>: Forces acting on all particles at the previous time step. Used for some integration schemes.</li><li><code>orientations::Vector{Float64}</code>: Current orientations of all particles, typically represented as an angle.</li><li><code>old_orientations::Vector{Float64}</code>: Orientations of all particles at the previous time step.</li><li><code>areas::Vector{Float64}</code>: Current areas of the Voronoi cell corresponding to each particle.</li><li><code>perimeters::Vector{Float64}</code>: Current perimeters of the Voronoi cell corresponding to each particle.</li><li><code>random_forces::Vector{Float64}</code>: Stores random numbers or forces, often used for implementing stochastic elements like rotational diffusion.</li><li><code>neighborlist::NB</code>: A structure (e.g., <code>VoronoiNeighborList</code>) that holds neighbor information for each particle, essential for calculating interactions and Voronoi properties.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SelfPropelledVoronoi.jl/blob/f0aa7c7de98f81fd2c55a5b5c6025886b736d884/src/DataStructs.jl#L81-L99">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SelfPropelledVoronoi.DumpInfo" href="#SelfPropelledVoronoi.DumpInfo"><code>SelfPropelledVoronoi.DumpInfo</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DumpInfo(; save=true, filename=&quot;dump_...&quot;, when_to_save_array=0:1000:1000000, save_r=true, save_F=false, save_Epot=false)</code></pre><p>A mutable struct that holds parameters for controlling the dumping (saving) of simulation data to a file. The type parameter <code>A</code> corresponds to the type of <code>when_to_save_array</code>, which is typically an array or range of integers.</p><p><strong>Fields</strong></p><ul><li><code>save::Bool</code>: A boolean flag to enable (<code>true</code>) or disable (<code>false</code>) the saving of simulation data. Defaults to <code>true</code>.</li><li><code>filename::String</code>: The name of the file where simulation data will be saved. Defaults to a randomly generated HDF5 filename (e.g., &quot;dump_12345.h5&quot;).</li><li><code>when_to_save_array::A</code>: An array or range specifying the simulation steps at which data should be saved. <code>A</code> is the type of this field, typically <code>AbstractArray</code>. Defaults to saving every 1000 steps up to 1,000,000.</li><li><code>save_r::Bool</code>: A boolean flag indicating whether to save particle positions (<code>true</code>) or not (<code>false</code>). Defaults to <code>true</code>.</li><li><code>save_F::Bool</code>: A boolean flag indicating whether to save particle forces (<code>true</code>) or not (<code>false</code>). Defaults to <code>false</code>.</li><li><code>save_Epot::Bool</code>: A boolean flag indicating whether to save the total potential energy of the system (<code>true</code>) or not (<code>false</code>). Defaults to <code>false</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SelfPropelledVoronoi.jl/blob/f0aa7c7de98f81fd2c55a5b5c6025886b736d884/src/DataStructs.jl#L147-L160">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SelfPropelledVoronoi.Output" href="#SelfPropelledVoronoi.Output"><code>SelfPropelledVoronoi.Output</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Output()</code></pre><p>A mutable struct that stores various simulation output quantities. These quantities are typically updated throughout the simulation and can be used for monitoring progress, logging, or analysis.</p><p><strong>Fields</strong></p><ul><li><code>potential_energy::Float64</code>: The total potential energy of the system at the current state.</li><li><code>steps_done::Int64</code>: The number of simulation time steps that have been completed.</li><li><code>N_voronoi_tesselations::Int64</code>: The total number of Voronoi tesselations that have been performed during the simulation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SelfPropelledVoronoi.jl/blob/f0aa7c7de98f81fd2c55a5b5c6025886b736d884/src/DataStructs.jl#L125-L135">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SelfPropelledVoronoi.ParameterStruct" href="#SelfPropelledVoronoi.ParameterStruct"><code>SelfPropelledVoronoi.ParameterStruct</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ParameterStruct(N =100, dt = 0.01, N_steps = 10000, kBT = 1.0, frictionconstant = 1.0,
                periodic_boundary_layer_depth = 1.0, verbose = false, box = SimulationBox(10.0, 10.0),
                particles = VoronoiCells(zeros(Float64, 100), zeros(Float64, 100), zeros(Float64, 100),
                                          zeros(Float64, 100), ones(Float64, 100), ones(Float64, 100)),
                dump_info = DumpInfo(), callback = x -&gt; nothing,
                RNG = Random.MersenneTwister(1234))</code></pre><p>A struct that holds all essential parameters for running a simulation. This includes physical parameters, numerical parameters, and settings for I/O and control.</p><p>Type parameters:</p><ul><li><code>P</code>: The type of the particle properties structure (e.g., <code>VoronoiCells</code>), which must be a subtype of <code>Particles</code>.</li><li><code>CB</code>: The type of the callback function.</li></ul><p><strong>Fields</strong></p><ul><li><code>N::Int</code>: The total number of particles in the simulation.</li><li><code>dt::Float64</code>: The time step size for the integration algorithm.</li><li><code>N_steps::Int</code>: The total number of simulation steps to perform.</li><li><code>kBT::Float64</code>: The thermal energy, given by the product of Boltzmann&#39;s constant (kB) and temperature (T).</li><li><code>frictionconstant::Float64</code>: The friction coefficient, determining the damping of particle motion.</li><li><code>periodic_boundary_layer_depth::Float64</code>: The depth of the layer around the simulation box used for periodic boundary condition checks and neighbor finding.</li><li><code>verbose::Bool</code>: A boolean flag to enable (<code>true</code>) or disable (<code>false</code>) verbose output during the simulation.</li><li><code>box::SimulationBox</code>: A <code>SimulationBox</code> struct defining the dimensions and properties of the simulation domain.</li><li><code>particles::P</code>: A struct (of type <code>P</code>) holding the specific properties of the particles (e.g., <code>VoronoiCells</code> which includes target areas, perimeters, etc.).</li><li><code>dump_info::DumpInfo</code>: A <code>DumpInfo</code> struct containing parameters for controlling how simulation data is saved to files.</li><li><code>callback::CB</code>: A callback function (of type <code>CB</code>) that can be executed at specified intervals during the simulation (e.g., for custom analysis or logging).</li><li><code>RNG::Random.MersenneTwister</code>: An instance of a random number generator (specifically <code>MersenneTwister</code>) used for stochastic processes in the simulation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SelfPropelledVoronoi.jl/blob/f0aa7c7de98f81fd2c55a5b5c6025886b736d884/src/DataStructs.jl#L211-L239">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SelfPropelledVoronoi.SimulationBox" href="#SelfPropelledVoronoi.SimulationBox"><code>SelfPropelledVoronoi.SimulationBox</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SimulationBox(Lx, Ly)</code></pre><p>Defines the simulation domain, typically a rectangular box with periodic boundary conditions.</p><p><strong>Fields</strong></p><ul><li><code>box_sizes::SVector{2, Float64}</code>: A 2D static vector representing the dimensions (Lx, Ly) of the simulation box. <code>Lx</code> is the width and <code>Ly</code> is the height.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SelfPropelledVoronoi.jl/blob/f0aa7c7de98f81fd2c55a5b5c6025886b736d884/src/DataStructs.jl#L36-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SelfPropelledVoronoi.VoronoiCells" href="#SelfPropelledVoronoi.VoronoiCells"><code>SelfPropelledVoronoi.VoronoiCells</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">VoronoiCells(target_perimeters, target_areas, K_P, K_A, active_force_strengths, rotational_diffusion_constants)</code></pre><p>Represents the properties of particles modeled as Voronoi cells. This struct stores parameters related to the mechanical properties (target area and perimeter, and associated spring constants) and active behavior (active force strength and rotational diffusion) of each particle/cell.</p><p><strong>Fields</strong></p><ul><li><code>target_perimeters::Vector{Float64}</code>: Target perimeters for each Voronoi cell. Deviations from these values incur an energy penalty.</li><li><code>target_areas::Vector{Float64}</code>: Target areas for each Voronoi cell. Deviations from these values incur an energy penalty.</li><li><code>K_P::Vector{Float64}</code>: Spring constants for perimeter deviations. Determines how strongly a cell resists changes to its perimeter.</li><li><code>K_A::Vector{Float64}</code>: Spring constants for area deviations. Determines how strongly a cell resists changes to its area.</li><li><code>active_force_strengths::Vector{Float64}</code>: Magnitudes of the active force for each particle. This force propels the particle in the direction of its orientation.</li><li><code>rotational_diffusion_constants::Vector{Float64}</code>: Rotational diffusion rates for each particle. This determines how quickly the particle&#39;s orientation changes randomly.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SelfPropelledVoronoi.jl/blob/f0aa7c7de98f81fd2c55a5b5c6025886b736d884/src/DataStructs.jl#L4-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SelfPropelledVoronoi.VoronoiNeighborList" href="#SelfPropelledVoronoi.VoronoiNeighborList"><code>SelfPropelledVoronoi.VoronoiNeighborList</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NeighborList</code></pre><p>A structure to hold the neighbor list and Voronoi edges for each particle. The <code>neighbors</code> field is a vector of vectors, where each inner vector contains the indices of the neighboring particles for each particle. The <code>voronoi_vertices</code> field is a vector of vectors, where each inner vector contains the index of the Voronoi vertices for each particle. The coordinates are accessed by <code>delauney_circumcenters</code> and are stored in counterclockwise order The <code>delauney_circumcenters</code> field is a vector of vectors, where each inner vector contains the coordinates of the Delauney circumcenters for each particle. The Delauney circumcenters are represented as <code>SVector{2, Float64}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SelfPropelledVoronoi.jl/blob/f0aa7c7de98f81fd2c55a5b5c6025886b736d884/src/DataStructs.jl#L51-L57">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SelfPropelledVoronoi.apply_periodic_boundary_conditions-Tuple{Any, Any}" href="#SelfPropelledVoronoi.apply_periodic_boundary_conditions-Tuple{Any, Any}"><code>SelfPropelledVoronoi.apply_periodic_boundary_conditions</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>apply<em>periodic</em>boundary<em>conditions(position, box</em>sizes)</p><p>Applies periodic boundary conditions to a given position, ensuring it wraps around the simulation box. For a position coordinate <code>x</code> and a box dimension <code>L</code>, the new coordinate <code>x&#39;</code> is <code>x - floor(x/L) * L</code>. This maps <code>x</code> to the interval <code>[0, L)</code>. The same logic applies to all dimensions.</p><p><strong>Arguments</strong></p><ul><li><code>position</code>: The original position, typically an <code>SVector</code> or any <code>AbstractVector</code> representing coordinates (e.g., <code>[x, y]</code>).</li><li><code>box_sizes</code>: The dimensions of the simulation box, typically an <code>SVector</code> or <code>AbstractVector</code> (e.g., <code>[Lx, Ly]</code>).</li></ul><p><strong>Returns</strong></p><ul><li><code>new_position</code>: The position after applying periodic boundary conditions, of the same type as <code>position</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SelfPropelledVoronoi.jl/blob/f0aa7c7de98f81fd2c55a5b5c6025886b736d884/src/AuxiliaryFunctions.jl#L2-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SelfPropelledVoronoi.circumcenter-Union{Tuple{T}, Tuple{StaticArraysCore.SVector{2, T}, StaticArraysCore.SVector{2, T}, StaticArraysCore.SVector{2, T}}} where T" href="#SelfPropelledVoronoi.circumcenter-Union{Tuple{T}, Tuple{StaticArraysCore.SVector{2, T}, StaticArraysCore.SVector{2, T}, StaticArraysCore.SVector{2, T}}} where T"><code>SelfPropelledVoronoi.circumcenter</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">circumcenter(a::SVector{2, T}, b::SVector{2, T}, c::SVector{2, T}) where T</code></pre><p>Calculates the circumcenter of a triangle defined by three 2D vertices <code>a</code>, <code>b</code>, and <code>c</code>. The circumcenter is the point where the perpendicular bisectors of the triangle&#39;s sides intersect, and it is equidistant from all three vertices. This point is also the center of the triangle&#39;s circumcircle.</p><p>The calculation is based on a standard formula for the circumcenter&#39;s coordinates (ux, uy) derived from the coordinates of the vertices (ax, ay), (bx, by), (cx, cy): D = 2 * (ax * (by - cy) + bx * (cy - ay) + cx * (ay - by)) ux = (1/D) * ((ax^2 + ay^2) * (by - cy) + (bx^2 + by^2) * (cy - ay) + (cx^2 + cy^2) * (ay - by)) uy = (1/D) * ((ax^2 + ay^2) * (cx - bx) + (bx^2 + by^2) * (ax - cx) + (cx^2 + cy^2) * (bx - ax)) This function uses <code>norm2</code> which computes <code>ax^2 + ay^2</code> (squared length from origin).</p><p><strong>Arguments</strong></p><ul><li><code>a::SVector{2, T}</code>: The 2D coordinates of the first vertex of the triangle. <code>T</code> is its element type.</li><li><code>b::SVector{2, T}</code>: The 2D coordinates of the second vertex of the triangle. <code>T</code> is its element type.</li><li><code>c::SVector{2, T}</code>: The 2D coordinates of the third vertex of the triangle. <code>T</code> is its element type.</li></ul><p><strong>Returns</strong></p><ul><li><code>SVector{2, Float64}</code>: The 2D coordinates <code>(ux, uy)</code> of the circumcenter. The coordinates are always returned as <code>Float64</code>, regardless of the input type <code>T</code>.</li></ul><p><strong>Notes</strong></p><ul><li>The function relies on <code>norm2(v)</code> to calculate the squared magnitude of vectors <code>a</code>, <code>b</code>, and <code>c</code> (from the origin), which are used in the circumcenter formula.</li><li>If the three points <code>a</code>, <code>b</code>, <code>c</code> are collinear, the denominator <code>D</code> will be zero, leading to <code>Inf</code> or <code>NaN</code> coordinates. This case is not explicitly handled here beyond the standard floating-point behavior.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SelfPropelledVoronoi.jl/blob/f0aa7c7de98f81fd2c55a5b5c6025886b736d884/src/Tesselation.jl#L248-L274">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SelfPropelledVoronoi.compute_energy-Tuple{Any, Any, Any}" href="#SelfPropelledVoronoi.compute_energy-Tuple{Any, Any, Any}"><code>SelfPropelledVoronoi.compute_energy</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_energy(parameters, arrays, output)</code></pre><p>Computes the total potential energy of the system. This energy is typically derived from the deviations of individual Voronoi cell areas and perimeters from their target values, penalized by corresponding spring constants.</p><p>This function first calls <code>update_areas!</code> and <code>update_perimeters!</code> to ensure that the current areas and perimeters in <code>arrays</code> are up-to-date before calculating the energy.</p><p><strong>Arguments</strong></p><ul><li><code>parameters::ParameterStruct</code>: The main simulation parameter struct. </li><li><code>arrays::ArrayStruct</code>: The struct holding simulation arrays. It&#39;s passed to <code>update_areas!</code> and <code>update_perimeters!</code>, which use <code>arrays.neighborlist.voronoi_vertex_positions_per_particle</code> and update <code>arrays.areas</code> and <code>arrays.perimeters</code>.</li><li><code>output::Output</code>: The simulation output struct. Passed to <code>update_areas!</code> and <code>update_perimeters!</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>potential_energy::Float64</code>: The total calculated potential energy of the system. This is the sum of energy contributions from each cell, where each cell&#39;s energy is <code>K_A * (area - target_area)^2 + K_P * (perimeter - target_perimeter)^2</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SelfPropelledVoronoi.jl/blob/f0aa7c7de98f81fd2c55a5b5c6025886b736d884/src/AuxiliaryFunctions.jl#L89-L106">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SelfPropelledVoronoi.compute_energy_i-NTuple{4, Any}" href="#SelfPropelledVoronoi.compute_energy_i-NTuple{4, Any}"><code>SelfPropelledVoronoi.compute_energy_i</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_energy_i(i, parameters, arrays, output)</code></pre><p>Computes the potential energy contribution of a single Voronoi cell indexed by <code>i</code>. This function calculates the energy based on the deviation of the cell&#39;s area and perimeter from their target values, penalized by the corresponding spring constants.</p><p><strong>Arguments</strong></p><ul><li><code>i::Int</code>: The index of the Voronoi cell for which to compute the energy.</li><li><code>parameters::ParameterStruct</code>: The main simulation parameter struct. Used to access target areas, target perimeters, and spring constants.</li><li><code>arrays::ArrayStruct</code>: The struct holding simulation arrays. Used to access the current areas and perimeters of the Voronoi cells.</li><li><code>output::Output</code>: The simulation output struct. Not directly used in this function but included for consistency in function signatures across the module.</li></ul><p><strong>Returns</strong></p><ul><li><code>E::Float64</code>: The computed energy for the Voronoi cell indexed by <code>i</code>. This is calculated as:</li></ul><p>K<em>A[i] * (areas[i] - target</em>areas[i])^2 + K<em>P[i] * (perimeters[i] - target</em>perimeters[i])^2</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SelfPropelledVoronoi.jl/blob/f0aa7c7de98f81fd2c55a5b5c6025886b736d884/src/AuxiliaryFunctions.jl#L119-L135">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SelfPropelledVoronoi.compute_forces_GCM!-Tuple{Any, Any, Any}" href="#SelfPropelledVoronoi.compute_forces_GCM!-Tuple{Any, Any, Any}"><code>SelfPropelledVoronoi.compute_forces_GCM!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_forces_GCM!(parameters, arrays, output)</code></pre><p>Computes the forces on each particle using a Gaussian Core Model (GCM). The GCM is a soft, repulsive pair potential where the force between two particles <code>i</code> and <code>j</code> is given by <code>F_ij = -2 * r_ij * exp(-r_ij^2)</code>, where <code>r_ij</code> is the distance vector between them. This function calculates the net force on each particle by summing these pairwise forces. Periodic boundary conditions are handled using <code>compute_pair_distance_vector</code>.</p><p>This function might serve as an alternative or simpler test case for force calculations compared to the more complex SPV model.</p><p><strong>Arguments</strong></p><ul><li><code>parameters::ParameterStruct</code>: The main simulation parameter struct. It provides:<ul><li><code>parameters.N</code>: The number of particles.</li><li><code>parameters.box.box_sizes</code>: Dimensions of the simulation box, used by <code>compute_pair_distance_vector</code>.</li></ul></li><li><code>arrays::ArrayStruct</code>: The struct holding simulation arrays.<ul><li><code>arrays.positions</code>: A vector of <code>SVector{2, Float64}</code> representing the current positions of all particles.</li><li><code>arrays.forces</code>: A vector of <code>SVector{2, Float64}</code> where the computed force for each particle will be stored. This array is modified in-place.</li></ul></li><li><code>output::Output</code>: The simulation output struct. Not directly used in this function but included for consistency in function signatures.</li></ul><p><strong>Notes</strong></p><ul><li>The function modifies <code>arrays.forces</code> in-place with the newly computed forces.</li><li>The interaction is considered only if the distance <code>r</code> is less than <code>2^(1/6)</code> (a common cutoff for this potential, related to its inflection point).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SelfPropelledVoronoi.jl/blob/f0aa7c7de98f81fd2c55a5b5c6025886b736d884/src/Forces.jl#L335-L359">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SelfPropelledVoronoi.compute_forces_SPV!-Tuple{Any, Any, Any}" href="#SelfPropelledVoronoi.compute_forces_SPV!-Tuple{Any, Any, Any}"><code>SelfPropelledVoronoi.compute_forces_SPV!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_forces_SPV!(parameters, arrays, output)</code></pre><p>Computes the forces on each particle based on the Self-Propelled Voronoi (SPV) model. The forces arise from deviations of cell areas and perimeters from their target values, effectively modeling area and perimeter elasticity.</p><p>The function first ensures the Voronoi tessellation is current by calling <code>verify_tesselation</code>. If the tessellation is not valid, it&#39;s updated by <code>voronoi_tesselation!</code> or <code>update_delauney_vertices!</code>. Subsequently, it calls <code>update_perimeters!</code> and <code>update_areas!</code> to ensure these geometric properties are current before force calculation.</p><p>The force on particle <code>i</code> is calculated as the negative gradient of the total potential energy with respect to its position <code>r_i</code>. This involves complex derivatives of cell areas and perimeters with respect to vertex positions, and then of vertex positions with respect to particle positions.</p><p><strong>Arguments</strong></p><ul><li><code>parameters::ParameterStruct</code>: The main simulation parameter struct. This provides access to:<ul><li><code>parameters.N</code>: Number of particles.</li><li><code>parameters.particles</code>: Contains <code>target_areas</code>, <code>target_perimeters</code>, <code>K_A</code> (area spring constant), <code>K_P</code> (perimeter spring constant).</li></ul></li><li><code>arrays::ArrayStruct</code>: The struct holding simulation arrays.<ul><li><code>arrays.neighborlist</code>: Used to access Voronoi neighbor information, vertex indices, vertex positions per particle, and positions with periodic boundary conditions.</li><li><code>arrays.areas</code>: Current areas of Voronoi cells (read after being updated by <code>update_areas!</code>).</li><li><code>arrays.perimeters</code>: Current perimeters of Voronoi cells (read after being updated by <code>update_perimeters!</code>).</li><li><code>arrays.forces</code>: A vector of <code>SVector{2, Float64}</code> where the computed force for each particle will be stored. This array is modified in-place.</li></ul></li><li><code>output::Output</code>: The simulation output struct. Passed to helper functions like <code>voronoi_tesselation!</code>, <code>update_perimeters!</code>, etc.</li></ul><p><strong>Notes</strong></p><ul><li>The function modifies <code>arrays.forces</code> in-place with the newly computed forces.</li><li>The calculation involves contributions from the particle&#39;s own cell energy (<code>dEi/dri</code>) and from the energy of its neighboring cells (<code>dEj/dri</code>).</li><li>The mathematical details of the force calculation (derivatives of geometry) can be complex and are implemented within the loops.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SelfPropelledVoronoi.jl/blob/f0aa7c7de98f81fd2c55a5b5c6025886b736d884/src/Forces.jl#L46-L79">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SelfPropelledVoronoi.compute_pair_distance_vector-Tuple{Any, Any, Any}" href="#SelfPropelledVoronoi.compute_pair_distance_vector-Tuple{Any, Any, Any}"><code>SelfPropelledVoronoi.compute_pair_distance_vector</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_pair_distance_vector(p1, p2, box_sizes)</code></pre><p>Computes the shortest vector (displacement) from particle <code>p1</code> to particle <code>p2</code> in a system with periodic boundary conditions (PBC). This is often referred to as the minimum image convention. For a coordinate difference <code>dx</code> and box dimension <code>L</code>, the PBC-aware difference <code>dx&#39;</code> is <code>dx - round(dx/L) * L</code>.</p><p><strong>Arguments</strong></p><ul><li><code>p1</code>: Position of the first particle (e.g., an <code>SVector</code> or <code>AbstractVector</code> like <code>[x1, y1]</code>).</li><li><code>p2</code>: Position of the second particle (e.g., an <code>SVector</code> or <code>AbstractVector</code> like <code>[x2, y2]</code>).</li><li><code>box_sizes</code>: Dimensions of the simulation box (e.g., an <code>SVector</code> or <code>AbstractVector</code> like <code>[Lx, Ly]</code>).</li></ul><p><strong>Returns</strong></p><ul><li><code>delta</code>: The displacement vector from <code>p1</code> to <code>p2</code> after applying the minimum image convention due to PBC. This will be of the same type as <code>p1</code> and <code>p2</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SelfPropelledVoronoi.jl/blob/f0aa7c7de98f81fd2c55a5b5c6025886b736d884/src/AuxiliaryFunctions.jl#L21-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SelfPropelledVoronoi.do_time_step-Tuple{Any, Any, Any}" href="#SelfPropelledVoronoi.do_time_step-Tuple{Any, Any, Any}"><code>SelfPropelledVoronoi.do_time_step</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">do_time_step(parameters, arrays, output)</code></pre><p>Advances the simulation by a single time step by calling an appropriate integration scheme.</p><p>This function acts as a dispatcher for different integration methods. Currently, it selects:</p><ul><li><code>do_time_step_Euler_Murayama</code> for the very first step of the simulation (<code>output.steps_done == 0</code>).</li><li><code>do_time_step_Euler_Heun!</code> for all subsequent steps.</li></ul><p>This strategy might be used, for example, to ensure proper initialization of &quot;old&quot; states required by more complex integrators like Heun&#39;s method.</p><p><strong>Arguments</strong></p><ul><li><code>parameters::ParameterStruct</code>: The main simulation parameter struct, containing settings like <code>dt</code>, particle properties, etc. Passed through to the chosen integrator function.</li><li><code>arrays::ArrayStruct</code>: The struct holding simulation arrays (positions, forces, orientations, etc.). These are modified in-place by the chosen integrator function.</li><li><code>output::Output</code>: The simulation output struct. <code>output.steps_done</code> is used to determine which integration scheme to use. It&#39;s also passed through to the chosen integrator function.</li></ul><p><strong>Returns</strong></p><ul><li>The function itself doesn&#39;t return a value but calls one of the integrator functions (<code>do_time_step_Euler_Murayama</code> or <code>do_time_step_Euler_Heun!</code>), which in turn modify <code>arrays</code> (and potentially <code>output</code>) in-place.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SelfPropelledVoronoi.jl/blob/f0aa7c7de98f81fd2c55a5b5c6025886b736d884/src/Dynamics.jl#L3-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SelfPropelledVoronoi.do_time_step_Euler_Heun!-Tuple{Any, Any, Any}" href="#SelfPropelledVoronoi.do_time_step_Euler_Heun!-Tuple{Any, Any, Any}"><code>SelfPropelledVoronoi.do_time_step_Euler_Heun!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">do_time_step_Euler_Heun!(parameters, arrays, output)</code></pre><p>Performs a single time step using the Euler-Heun predictor-corrector integration scheme. This method is suitable for stochastic differential equations (SDEs) and offers better stability and accuracy than the simpler Euler-Maruyama method for some systems. It involves predicting a future state and then correcting it using an average of forces/drifts.</p><p>The operational steps are:</p><ol><li><strong>Compute forces at current positions</strong>: <code>compute_forces_SPV!</code> is called to get forces <code>F(x(t_n))</code> based on current <code>arrays.positions</code> (state at <code>t_n</code>).</li><li><strong>Update orientations</strong>: Particle orientations <code>θ(t_n)</code> are updated to <code>θ(t_{n+1})</code> by adding a stochastic rotational diffusion term. <code>arrays.orientations</code> now stores <code>θ(t_{n+1})</code>. The orientations from the start of the step, <code>θ(t_n)</code>, are available in <code>arrays.old_orientations</code> (assuming they were stored from a previous step or initialization).</li><li><strong>Predictor step</strong>:<ul><li>A predicted position <code>x_tilde(t_{n+1})</code> is calculated using forces <code>F(x(t_n))</code> and active forces based on orientations <code>θ(t_n)</code> (from <code>arrays.old_orientations</code>).</li><li><code>arrays.positions</code> are updated to these predicted positions.</li></ul></li><li><strong>Store current forces</strong>: The forces <code>F(x(t_n))</code> (used in the predictor step) are stored in <code>arrays.old_forces</code>.</li><li><strong>Compute forces at predicted positions</strong>: <code>compute_forces_SPV!</code> is called again to calculate forces <code>F(x_tilde(t_{n+1}))</code> based on the predicted <code>arrays.positions</code>. <code>arrays.forces</code> now stores these new forces.</li><li><strong>Corrector step</strong>:<ul><li>The final positions <code>x(t_{n+1})</code> are calculated using an average of the &quot;old&quot; forces/orientations and the &quot;new&quot; (predicted) forces/orientations.   Specifically, it uses <code>0.5 * [ (F(x(t_n)) + v_active(θ(t_n))) + (F(x_tilde(t_{n+1})) + v_active(θ(t_{n+1}))) ]</code>.</li><li><code>arrays.positions</code> are updated to these corrected positions.</li></ul></li><li><strong>Update &quot;old&quot; states</strong>: <code>arrays.old_positions</code> are updated with the corrected <code>arrays.positions</code>, and <code>arrays.old_orientations</code> are updated with <code>arrays.orientations</code> (<code>θ(t_{n+1})</code>) to prepare for the next time step.</li></ol><p><strong>Arguments</strong></p><ul><li><code>parameters::ParameterStruct</code>: The main simulation parameter struct, providing:<ul><li><code>dt::Float64</code>: The time step size.</li><li><code>frictionconstant::Float64</code>: Used to calculate mobility (<code>1 / frictionconstant</code>).</li><li><code>particles.active_force_strengths::Vector{Float64}</code>: Magnitudes of the active force.</li><li><code>particles.rotational_diffusion_constants::Vector{Float64}</code>: Rotational diffusion rates.</li><li><code>N::Int</code>: The total number of particles.</li><li><code>box.box_sizes::SVector{2, Float64}</code>: Dimensions for periodic boundary conditions.</li></ul></li><li><code>arrays::ArrayStruct</code>: The struct holding simulation arrays. The following are used and modified in-place:<ul><li><code>positions::Vector{SVector{2, Float64}}</code>: Initially <code>x(t_n)</code>, then <code>x_tilde(t_{n+1})</code>, then corrected <code>x(t_{n+1})</code>.</li><li><code>forces::Vector{SVector{2, Float64}}</code>: Initially stores <code>F(x(t_n))</code>, then <code>F(x_tilde(t_{n+1}))</code>.</li><li><code>orientations::Vector{Float64}</code>: Updated to <code>θ(t_{n+1})</code> after rotational diffusion.</li><li><code>old_positions::Vector{SVector{2, Float64}}</code>: Stores <code>x(t_n)</code> at the start, updated to corrected <code>x(t_{n+1})</code> at the end.</li><li><code>old_forces::Vector{SVector{2, Float64}}</code>: Updated to store <code>F(x(t_n))</code>.</li><li><code>old_orientations::Vector{Float64}</code>: Stores <code>θ(t_n)</code> at the start, updated to <code>θ(t_{n+1})</code> at the end.</li></ul></li><li><code>output::Output</code>: The simulation output struct. Passed to <code>compute_forces_SPV!</code>.</li></ul><p><strong>Notes</strong></p><ul><li>All relevant fields in <code>arrays</code> are modified in-place throughout the function.</li><li>This scheme aims for better accuracy by averaging drifts over the interval.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SelfPropelledVoronoi.jl/blob/f0aa7c7de98f81fd2c55a5b5c6025886b736d884/src/Dynamics.jl#L112-L154">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SelfPropelledVoronoi.do_time_step_Euler_Murayama-Tuple{Any, Any, Any}" href="#SelfPropelledVoronoi.do_time_step_Euler_Murayama-Tuple{Any, Any, Any}"><code>SelfPropelledVoronoi.do_time_step_Euler_Murayama</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">do_time_step_Euler_Murayama(parameters, arrays, output)</code></pre><p>Performs a single time step using the Euler-Maruyama integration scheme, suitable for stochastic differential equations (SDEs). This method updates particle positions and orientations considering deterministic forces, active self-propulsion forces, and stochastic rotational diffusion.</p><p>The function first calls <code>compute_forces_SPV!</code> to calculate the current deterministic forces on all particles based on their positions and Voronoi cell properties. Then, it updates orientations by adding a random component scaled by the rotational diffusion constant. Finally, it updates positions based on the sum of deterministic forces and active forces (directed by the orientation at the <em>beginning</em> of the step), scaled by mobility and time step <code>dt</code>. Periodic boundary conditions are applied to the new positions.</p><p>At the end of the step, the <code>old_positions</code>, <code>old_forces</code>, and <code>old_orientations</code> arrays are updated to store the state for potential use in subsequent, more complex integration schemes (though this specific integrator is often used as a simpler baseline or for the first step).</p><p><strong>Arguments</strong></p><ul><li><code>parameters::ParameterStruct</code>: The main simulation parameter struct, providing:<ul><li><code>dt::Float64</code>: The time step size.</li><li><code>frictionconstant::Float64</code>: Used to calculate mobility (<code>1 / frictionconstant</code>).</li><li><code>particles.active_force_strengths::Vector{Float64}</code>: Magnitudes of the active force for each particle.</li><li><code>particles.rotational_diffusion_constants::Vector{Float64}</code>: Rotational diffusion rates for each particle.</li><li><code>N::Int</code>: The total number of particles.</li><li><code>box.box_sizes::SVector{2, Float64}</code>: Dimensions of the simulation box for periodic boundary conditions.</li></ul></li><li><code>arrays::ArrayStruct</code>: The struct holding simulation arrays. The following fields are used and modified:<ul><li><code>positions::Vector{SVector{2, Float64}}</code>: Updated in-place with new particle positions.</li><li><code>forces::Vector{SVector{2, Float64}}</code>: Updated in-place by <code>compute_forces_SPV!</code>.</li><li><code>orientations::Vector{Float64}</code>: Updated in-place with new particle orientations.</li><li><code>old_positions::Vector{SVector{2, Float64}}</code>: Updated in-place to store the new <code>positions</code>.</li><li><code>old_forces::Vector{SVector{2, Float64}}</code>: Updated in-place to store the new <code>forces</code>.</li><li><code>old_orientations::Vector{Float64}</code>: Updated in-place to store the new <code>orientations</code>. (Note: the position update uses orientations from <em>before</em> this step&#39;s rotational diffusion for the active force direction).</li></ul></li><li><code>output::Output</code>: The simulation output struct. Passed to <code>compute_forces_SPV!</code>.</li></ul><p><strong>Notes</strong></p><ul><li>All relevant fields in <code>arrays</code> (positions, forces, orientations, old<em>positions, old</em>forces, old_orientations) are modified in-place.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SelfPropelledVoronoi.jl/blob/f0aa7c7de98f81fd2c55a5b5c6025886b736d884/src/Dynamics.jl#L32-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SelfPropelledVoronoi.norm2-Union{Tuple{StaticArraysCore.SVector{2, T}}, Tuple{T}} where T" href="#SelfPropelledVoronoi.norm2-Union{Tuple{StaticArraysCore.SVector{2, T}}, Tuple{T}} where T"><code>SelfPropelledVoronoi.norm2</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">norm2(v::SVector{2, T}) where T</code></pre><p>Computes the squared Euclidean norm (also known as squared length or squared magnitude) of a 2D vector <code>v</code>.</p><p>For a vector <code>v = [v1, v2]</code>, this is calculated as <code>v1^2 + v2^2</code>. This is often used in computations where the actual distance (square root) is not needed, as it avoids a potentially costly square root operation.</p><p><strong>Arguments</strong></p><ul><li><code>v::SVector{2, T}</code>: The 2D input vector. <code>T</code> is its element type (e.g., <code>Float64</code>).</li></ul><p><strong>Returns</strong></p><ul><li><code>::T</code>: The squared Euclidean norm of the vector <code>v</code>, equal to <code>v[1]^2 + v[2]^2</code>. The return type is the same as the element type of the input vector.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SelfPropelledVoronoi.jl/blob/f0aa7c7de98f81fd2c55a5b5c6025886b736d884/src/Tesselation.jl#L228-L243">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SelfPropelledVoronoi.replace_or_push!-Tuple{Any, Any, Any}" href="#SelfPropelledVoronoi.replace_or_push!-Tuple{Any, Any, Any}"><code>SelfPropelledVoronoi.replace_or_push!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">replace_or_push!(array, value, index)</code></pre><p>Modifies an <code>array</code> in-place by either replacing an element at a specified <code>index</code> or pushing a new <code>value</code> onto the end of the array.</p><p>The behavior is as follows:</p><ul><li>If <code>index</code> is within the current bounds of the <code>array</code> (i.e., <code>1 &lt;= index &lt;= length(array)</code>), the element at <code>array[index]</code> is replaced with <code>value</code>.</li><li>If <code>index</code> is one greater than the current length of the <code>array</code> (i.e., <code>index == length(array) + 1</code>), the <code>value</code> is pushed onto the end of the <code>array</code> using <code>push!</code>.</li><li>If <code>index</code> is out of these bounds (e.g., less than 1, or greater than <code>length(array) + 1</code>), an <code>ArgumentError</code> is thrown.</li></ul><p><strong>Arguments</strong></p><ul><li><code>array</code>: The array to be modified. This array is changed in-place.</li><li><code>value</code>: The value to be inserted into the <code>array</code> or pushed onto its end.</li><li><code>index::Integer</code>: The index at which to replace the existing element, or the position (equal to <code>length(array) + 1</code>) where the new element should be pushed.</li></ul><p><strong>Returns</strong></p><ul><li>The function does not explicitly return a value (<code>nothing</code> is implicitly returned if an <code>ArgumentError</code> is not thrown). The primary effect is the modification of the input <code>array</code>.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>index</code> is not within the valid range for replacement or pushing (i.e., if <code>index &lt; 1</code> or <code>index &gt; length(array) + 1</code>).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SelfPropelledVoronoi.jl/blob/f0aa7c7de98f81fd2c55a5b5c6025886b736d884/src/Tesselation.jl#L3-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SelfPropelledVoronoi.run_simulation!-NTuple{4, Any}" href="#SelfPropelledVoronoi.run_simulation!-NTuple{4, Any}"><code>SelfPropelledVoronoi.run_simulation!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">run_simulation!(parameters, arrays, output, N_steps)</code></pre><p>Runs the main simulation loop for a specified number of time steps.</p><p>Before starting the loop, it performs an initial Voronoi tessellation by calling <code>voronoi_tesselation!(parameters, arrays, output)</code> to ensure the system&#39;s geometric properties are up-to-date.</p><p>The main loop then proceeds as follows for each step:</p><ol><li><strong>Verbose Output</strong>: If <code>parameters.verbose</code> is true and the current step is a multiple of 100, the step number is printed to the console.</li><li><strong>Callback Invocation</strong>: The user-provided <code>parameters.callback</code> function is called, passing <code>parameters</code>, <code>arrays</code>, and <code>output</code>. This allows for custom actions or analysis during the simulation.</li><li><strong>Time Step Advancement</strong>: <code>do_time_step(parameters, arrays, output)</code> is called to advance the simulation state by one time step, updating particle positions, orientations, and forces.</li><li><strong>Data Dumping</strong>: If <code>parameters.dump_info.save</code> is true, it checks if the current <code>step</code> is in <code>parameters.dump_info.when_to_save_array</code>. If so, <code>save_simulation_state!(parameters, arrays, output)</code> is called to save the current simulation state.</li><li><strong>Step Counting</strong>: The local <code>step</code> counter is incremented, and <code>output.steps_done</code> is updated to reflect the completed step.</li><li><strong>Termination</strong>: The loop breaks if <code>step</code> exceeds <code>N_steps</code>.</li></ol><p><strong>Arguments</strong></p><ul><li><code>parameters::ParameterStruct</code>: The main simulation parameter struct. Key fields used:<ul><li><code>verbose::Bool</code>: Flag to enable/disable verbose output.</li><li><code>dump_info::DumpInfo</code>: Contains parameters for saving simulation data, including <code>save</code> (flag), <code>when_to_save_array</code> (steps for saving).</li><li><code>callback</code>: A user-defined function called at each step.</li></ul></li><li><code>arrays::ArrayStruct</code>: The struct holding simulation arrays (positions, forces, orientations, etc.). This is modified in-place by the functions called within the loop (e.g., <code>do_time_step</code>, <code>voronoi_tesselation!</code>).</li><li><code>output::Output</code>: The simulation output struct.<ul><li><code>output.steps_done</code>: Used to initialize the local <code>step</code> counter and is updated at each iteration. It is also passed to and modified by functions called within the loop.</li></ul></li><li><code>N_steps::Int</code>: The total number of time steps to run the simulation.</li></ul><p><strong>Notes</strong></p><ul><li>The <code>arrays</code> and <code>output</code> structs are modified in-place throughout the simulation by the various functions called.</li><li>The simulation starts from the step number indicated by <code>output.steps_done</code> at the beginning of the function call.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SelfPropelledVoronoi.jl/blob/f0aa7c7de98f81fd2c55a5b5c6025886b736d884/src/Dynamics.jl#L227-L257">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SelfPropelledVoronoi.save_simulation_state!-Tuple{ParameterStruct, ArrayStruct, Output}" href="#SelfPropelledVoronoi.save_simulation_state!-Tuple{ParameterStruct, ArrayStruct, Output}"><code>SelfPropelledVoronoi.save_simulation_state!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">save_simulation_state!(parameters::ParameterStruct, arrays::ArrayStruct, output::Output)</code></pre><p>Saves the current state of the simulation to an HDF5 file.</p><p>The function uses the filename specified in <code>parameters.dump_info.filename</code>. It only supports files with <code>.h5</code> or <code>.hdf5</code> extensions.</p><p><strong>File Structure:</strong></p><p>If the HDF5 file does not exist, it will be created, and initial simulation parameters will be saved under the <code>/parameters</code> group. These include:</p><ul><li><code>/parameters/N</code>: Number of particles</li><li><code>/parameters/dt</code>: Timestep size</li><li><code>/parameters/kBT</code>: Boltzmann temperature</li><li><code>/parameters/frictionconstant</code>: Friction constant</li><li><code>/parameters/box_sizes</code>: Dimensions of the simulation box (SVector)</li><li><code>/parameters/particles/target_perimeters</code>: Target perimeters for Voronoi cells</li><li><code>/parameters/particles/target_areas</code>: Target areas for Voronoi cells</li><li><code>/parameters/particles/K_P</code>: Perimeter stiffness constants</li><li><code>/parameters/particles/K_A</code>: Area stiffness constants</li><li><code>/parameters/particles/active_force_strengths</code>: Active force strengths</li><li><code>/parameters/particles/rotational_diffusion_constants</code>: Rotational diffusion constants</li></ul><p>For both new and existing files, the simulation data for the current step (obtained from <code>output.steps_done</code>) is saved in a new group named after the step number (e.g., <code>/0</code>, <code>/1000</code>, etc.).</p><p>Each step group (<code>/&lt;step_number&gt;/</code>) contains the following datasets, depending on the flags in <code>parameters.dump_info</code>:</p><ul><li><code>positions</code>: Vector of SVector{2, Float64} (saved if <code>dump_info.save_r</code> is true)</li><li><code>orientations</code>: Vector{Float64} (saved if <code>dump_info.save_r</code> is true)</li><li><code>forces</code>: Vector of SVector{2, Float64} (saved if <code>dump_info.save_F</code> is true)</li><li><code>potential_energy</code>: Float64 (saved if <code>dump_info.save_Epot</code> is true)</li><li><code>areas</code>: Vector{Float64} (always saved)</li><li><code>perimeters</code>: Vector{Float64} (always saved)</li></ul><p><strong>Usage Example:</strong></p><pre><code class="language-julia hljs"># Assuming `params`, `arrs`, `outs` are populated ParameterStruct, ArrayStruct, and Output instances
# and params.dump_info is configured.
save_simulation_state!(params, arrs, outs)</code></pre><p>The function returns <code>nothing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SelfPropelledVoronoi.jl/blob/f0aa7c7de98f81fd2c55a5b5c6025886b736d884/src/Dump.jl#L4-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SelfPropelledVoronoi.sort_indices_counter_clockwise-NTuple{4, Any}" href="#SelfPropelledVoronoi.sort_indices_counter_clockwise-NTuple{4, Any}"><code>SelfPropelledVoronoi.sort_indices_counter_clockwise</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sort_indices_counter_clockwise(voronoi_vertex_indices, voronoi_vertex_positions_per_particle, voronoi_vertices, voronoi_center, Lx, Ly)</code></pre><p>Sorts the Voronoi vertex indices and their corresponding positions for a specific particle&#39;s Voronoi cell in a counter-clockwise (CCW) order around the cell&#39;s center.</p><p>The sorting is achieved by calculating the angle of each vertex relative to the <code>voronoi_center</code> (the particle&#39;s position) and then sorting based on these angles. The <code>atan(dy, dx)</code> function is used to get angles in the range <code>(-π, π]</code>, which naturally provides an ordering for CCW sorting.</p><p><strong>Arguments</strong></p><ul><li><code>voronoi_vertex_indices::Vector{Int}</code>: A vector of integer indices pointing to the global <code>voronoi_vertices</code> list. These are the vertices associated with the specific particle&#39;s cell before sorting.</li><li><code>voronoi_vertex_positions_per_particle::Vector{SVector{2, Float64}}</code>: A vector of 2D positions (<code>SVector{2, Float64}</code>) of the Voronoi vertices, corresponding element-wise to <code>voronoi_vertex_indices</code>. This list is also sorted along with <code>voronoi_vertex_indices</code>.</li><li><code>voronoi_vertices::Vector{SVector{2, Float64}}</code>: The global list containing the 2D positions of all Voronoi vertices in the system. The indices in <code>voronoi_vertex_indices</code> refer to this list.</li><li><code>voronoi_center::SVector{2, Float64}</code>: The 2D position of the center of the Voronoi cell, which is the position of the particle itself. This is the reference point for angle calculations.</li><li><code>Lx::Float64</code>: The width of the simulation box. Currently unused in this function.</li><li><code>Ly::Float64</code>: The height of the simulation box. Currently unused in this function.</li></ul><p><strong>Returns</strong></p><ul><li><code>Tuple{Vector{Int}, Vector{SVector{2, Float64}}}</code>: A tuple containing two new vectors:<ol><li>The sorted <code>voronoi_vertex_indices</code> for the particle&#39;s cell, ordered counter-clockwise.</li><li>The correspondingly sorted <code>voronoi_vertex_positions_per_particle</code>.</li></ol></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SelfPropelledVoronoi.jl/blob/f0aa7c7de98f81fd2c55a5b5c6025886b736d884/src/Tesselation.jl#L189-L212">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SelfPropelledVoronoi.update_areas!-Tuple{Any, Any, Any}" href="#SelfPropelledVoronoi.update_areas!-Tuple{Any, Any, Any}"><code>SelfPropelledVoronoi.update_areas!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update_areas!(parameters, arrays, output)</code></pre><p>Calculates and updates the areas of all Voronoi cells. The area of each cell is computed using the shoelace formula (also known as Gauss&#39;s area formula), based on the coordinates of its Voronoi vertices. The results are stored in <code>arrays.areas</code>.</p><p><strong>Arguments</strong></p><ul><li><code>parameters::ParameterStruct</code>: The main simulation parameter struct. Used here to get <code>N</code>, the number of particles.</li><li><code>arrays::ArrayStruct</code>: The struct holding simulation arrays.</li><li><code>output::Output</code>: The simulation output struct. Not directly used in this function but included for consistency in function signatures across the module.</li></ul><p><strong>Notes</strong></p><ul><li>This function assumes that the Voronoi vertex positions for each cell are already calculated and available in <code>arrays.neighborlist.voronoi_vertex_positions_per_particle</code>, and that these vertices are ordered sequentially.</li><li>The <code>arrays.areas</code> vector is updated in-place with the new area values. The shoelace formula calculates signed area, so the division by 2.0 yields the geometric area assuming a consistent vertex ordering.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SelfPropelledVoronoi.jl/blob/f0aa7c7de98f81fd2c55a5b5c6025886b736d884/src/AuxiliaryFunctions.jl#L65-L80">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SelfPropelledVoronoi.update_perimeters!-Tuple{Any, Any, Any}" href="#SelfPropelledVoronoi.update_perimeters!-Tuple{Any, Any, Any}"><code>SelfPropelledVoronoi.update_perimeters!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update_perimeters!(parameters, arrays, output)</code></pre><p>Calculates and updates the perimeters of all Voronoi cells. The perimeter of each cell is computed by summing the lengths of the segments connecting its Voronoi vertices in sequence. The results are stored in <code>arrays.perimeters</code>.</p><p><strong>Arguments</strong></p><ul><li><code>parameters::ParameterStruct</code>: The main simulation parameter struct. Used here to get <code>N</code>, the number of particles.</li><li><code>arrays::ArrayStruct</code>: The struct holding simulation arrays. </li><li><code>output::Output</code>: The simulation output struct. Not directly used in this function but included for consistency in function signatures across the module.</li></ul><p><strong>Notes</strong></p><ul><li>This function assumes that the Voronoi vertex positions for each cell are already calculated and available in <code>arrays.neighborlist.voronoi_vertex_positions_per_particle</code>.</li><li>The <code>arrays.perimeters</code> vector is updated in-place with the new perimeter values.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SelfPropelledVoronoi.jl/blob/f0aa7c7de98f81fd2c55a5b5c6025886b736d884/src/AuxiliaryFunctions.jl#L43-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SelfPropelledVoronoi.update_positions_with_pbcs!-Tuple{Any, Any, Any}" href="#SelfPropelledVoronoi.update_positions_with_pbcs!-Tuple{Any, Any, Any}"><code>SelfPropelledVoronoi.update_positions_with_pbcs!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update_positions_with_pbcs!(parameters, arrays, output)</code></pre><p>Creates an extended list of particle positions that includes the original particles and their periodic images located within a defined boundary layer around the simulation box. This extended list is essential for Voronoi tessellation algorithms to correctly construct Voronoi cells for particles near the boundaries of the periodic domain.</p><p>The function first adds all original particle positions. Then, for each original particle, it checks if it&#39;s close to any of the box boundaries (left, right, bottom, top) or corners. If a particle is within <code>pbc_layer_depth</code> of a boundary, its corresponding periodic image(s) across that boundary (or corner) are added to the list.</p><p>The generated list of positions (<code>arrays.neighborlist.positions_with_pbc</code>) and a corresponding list of original particle indices (<code>arrays.neighborlist.position_indices</code>) are stored in the <code>arrays.neighborlist</code> structure.</p><p><strong>Arguments</strong></p><ul><li><code>parameters::ParameterStruct</code>: The main simulation parameter struct, providing:</li><li><code>arrays::ArrayStruct</code>: The struct holding simulation arrays.</li><li><code>output::Output</code>: The simulation output struct. Not directly used in this function but included for consistency in function signatures.</li></ul><p><strong>Notes</strong></p><ul><li>The fields <code>arrays.neighborlist.positions_with_pbc</code> and <code>arrays.neighborlist.position_indices</code> are modified in-place.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SelfPropelledVoronoi.jl/blob/f0aa7c7de98f81fd2c55a5b5c6025886b736d884/src/Tesselation.jl#L39-L64">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SelfPropelledVoronoi.update_voronoi_vertices!-NTuple{4, Any}" href="#SelfPropelledVoronoi.update_voronoi_vertices!-NTuple{4, Any}"><code>SelfPropelledVoronoi.update_voronoi_vertices!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SelfPropelledVoronoi.jl/blob/f0aa7c7de98f81fd2c55a5b5c6025886b736d884/src/Tesselation.jl#L384-L386">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SelfPropelledVoronoi.verify_tessellation-Tuple{Any, Any, Any}" href="#SelfPropelledVoronoi.verify_tessellation-Tuple{Any, Any, Any}"><code>SelfPropelledVoronoi.verify_tessellation</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">verify_tesselation(parameters, arrays, output)</code></pre><p>Verifies the validity of the Voronoi tessellation by checking if all particles are correctly positioned with respect to the Delaunay facets of the tessellation. This function checks that for each Delaunay facet (triangle) defined by a triplet of particles, the circumcircle of the triangle does not contain any other particle that is not one of the triangle&#39;s vertices.</p><p><strong>Arguments</strong></p><ul><li><code>parameters::ParameterStruct</code>: The main simulation parameter struct, providing the number of particles <code>N</code>.</li><li><code>arrays::ArrayStruct</code>: The struct holding simulation arrays, including positions and neighbor lists.</li><li><code>output::Output</code>: The simulation output struct. Not directly used in this function but included for consistency in function signatures.</li></ul><p><strong>Returns</strong></p><ul><li><code>Bool</code>: Returns <code>true</code> if the tessellation is valid (no violations found), or <code>false</code> if any particle is found within the circumcircle of a Delaunay facet that is not one of its vertices.</li></ul><p><strong>Notes</strong></p><ul><li>The function assumes that the Voronoi tessellation has already been computed and that the necessary fields in <code>arrays.neighborlist</code> are populated, including <code>delaunay_facet_triplets</code>, <code>positions_with_pbc</code>, and <code>voronoi_neighbors</code>.</li><li>The field arrays.neighborlist.positions<em>with</em>pbc is updated to include periodic boundary conditions.</li><li>If the flag <code>arrays.neighborlist.check_tesselation</code> is set to <code>false</code>, the function immediately returns <code>false</code>, indicating that tessellation verification is not required or has been disabled.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SelfPropelledVoronoi.jl/blob/f0aa7c7de98f81fd2c55a5b5c6025886b736d884/src/Tesselation.jl#L290-L307">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SelfPropelledVoronoi.voronoi_tesselation!-Tuple{Any, Any, Any}" href="#SelfPropelledVoronoi.voronoi_tesselation!-Tuple{Any, Any, Any}"><code>SelfPropelledVoronoi.voronoi_tesselation!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">voronoi_tesselation!(parameters, arrays, output)</code></pre><p>Performs a full Voronoi tessellation of the system based on current particle positions. This function orchestrates several steps to compute the Voronoi diagram, which is dual to the Delaunay triangulation. The results, including lists of Voronoi neighbors, vertex positions, and topological information, are stored in <code>arrays.neighborlist</code>.</p><p>The process involves:</p><ol><li><strong>Update Positions with PBC</strong>: Calls <code>update_positions_with_pbcs!</code> to generate an extended list of particle positions, including periodic images necessary for correct tessellation across boundaries. This list is stored in <code>arrays.neighborlist.positions_with_pbc</code>.</li><li><strong>Delaunay Triangulation</strong>: Computes the Delaunay triangulation of the extended particle positions using <code>Quickhull.delaunay</code>.</li><li><strong>Process Delaunay Facets</strong>: Iterates through each facet (triangle) of the Delaunay triangulation:<ul><li>The three particles forming the triangle are identified as Voronoi neighbors of each other. These are added to <code>arrays.neighborlist.voronoi_neighbors</code>.</li><li>The circumcenter of the Delaunay triangle is calculated using the <code>circumcenter</code> function. This circumcenter is a Voronoi vertex. It&#39;s added to a global list of <code>voronoi_vertices</code> and also to <code>arrays.neighborlist.voronoi_vertex_positions_per_particle</code> for each of the three particles forming the triangle.</li><li>The index of this new Voronoi vertex is added to <code>arrays.neighborlist.voronoi_vertex_indices</code> for each of the three particles.</li><li>A tuple of the three particle indices forming the triangle (cell centers sharing this Voronoi vertex) is stored in <code>arrays.neighborlist.cell_centers_that_share_a_vertex</code>.</li></ul></li><li><strong>Sort Voronoi Vertices</strong>: For each of the original <code>N</code> particles, the collected Voronoi vertices associated with it are sorted in counter-clockwise order around the particle&#39;s actual position using <code>sort_indices_counter_clockwise</code>. This ensures a consistent representation of Voronoi cells. The sorted vertex indices and positions replace the unsorted ones in <code>arrays.neighborlist.voronoi_vertex_indices</code> and <code>arrays.neighborlist.voronoi_vertex_positions_per_particle</code> for the original particles.</li><li><strong>Store Results</strong>: All computed lists (global Voronoi vertices, neighbors per particle, vertex indices per particle, vertex positions per particle, and cell centers sharing a vertex) are stored in the corresponding fields of <code>arrays.neighborlist</code>.</li></ol><p><strong>Arguments</strong></p><ul><li><code>parameters::ParameterStruct</code>: The main simulation parameter struct.</li><li><code>arrays::ArrayStruct</code>: The struct holding simulation arrays.</li><li><code>output::Output</code>: The simulation output struct. Passed to <code>update_positions_with_pbcs!</code>.</li></ul><p><strong>Notes</strong></p><ul><li>This function heavily modifies the <code>arrays.neighborlist</code> structure in-place.</li><li>It relies on <code>Quickhull.jl</code> for the Delaunay triangulation and helper functions like <code>update_positions_with_pbcs!</code>, <code>circumcenter</code>, and <code>sort_indices_counter_clockwise</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SelfPropelledVoronoi.jl/blob/f0aa7c7de98f81fd2c55a5b5c6025886b736d884/src/Tesselation.jl#L150-L177">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SelfPropelledVoronoi.when_to_print_array-Tuple{Any}" href="#SelfPropelledVoronoi.when_to_print_array-Tuple{Any}"><code>SelfPropelledVoronoi.when_to_print_array</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">compute_msd(displacement_array)</code></pre><p>returns [1,2,3,4,5,6,7,8,9,10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 200, etc]     Computes the mean squared displacement (MSD) of particles based on their displacement vectors.     The MSD is a measure of the average squared distance that particles have moved from their initial positions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IlianPihlajamaa/SelfPropelledVoronoi.jl/blob/f0aa7c7de98f81fd2c55a5b5c6025886b736d884/src/AuxiliaryFunctions.jl#L185-L191">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/">« Examples</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.11.4 on <span class="colophon-date" title="Monday 2 June 2025 08:10">Monday 2 June 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
