var documenterSearchIndex = {"docs":
[{"location":"api/","page":"API Reference","title":"API Reference","text":"Modules = [SelfPropelledVoronoi]\nOrder   = [:module, :constant, :type, :macro, :function]","category":"page"},{"location":"api/#SelfPropelledVoronoi.ArrayStruct","page":"API Reference","title":"SelfPropelledVoronoi.ArrayStruct","text":"ArrayStruct(N)\n\nA structure that holds various arrays for storing particle properties and the simulation state. These arrays are typically updated at each time step of the simulation. The type parameter NB refers to the type of the neighbor list structure used (e.g., VoronoiNeighborList).\n\nFields\n\npositions::Vector{SVector{2, Float64}}: Current 2D positions of all particles.\nold_positions::Vector{SVector{2, Float64}}: Positions of all particles at the previous time step. Used for some integration schemes or state tracking.\nforces::Vector{SVector{2, Float64}}: Current 2D forces acting on all particles.\nold_forces::Vector{SVector{2, Float64}}: Forces acting on all particles at the previous time step. Used for some integration schemes.\norientations::Vector{Float64}: Current orientations of all particles, typically represented as an angle.\nold_orientations::Vector{Float64}: Orientations of all particles at the previous time step.\nareas::Vector{Float64}: Current areas of the Voronoi cell corresponding to each particle.\nperimeters::Vector{Float64}: Current perimeters of the Voronoi cell corresponding to each particle.\nrandom_forces::Vector{Float64}: Stores random numbers or forces, often used for implementing stochastic elements like rotational diffusion.\nneighborlist::NB: A structure (e.g., VoronoiNeighborList) that holds neighbor information for each particle, essential for calculating interactions and Voronoi properties.\n\n\n\n\n\n","category":"type"},{"location":"api/#SelfPropelledVoronoi.DumpInfo","page":"API Reference","title":"SelfPropelledVoronoi.DumpInfo","text":"DumpInfo(; save=true, filename=\"dump_...\", when_to_save_array=0:1000:1000000, save_r=true, save_F=false, save_Epot=false)\n\nA mutable struct that holds parameters for controlling the dumping (saving) of simulation data to a file. The type parameter A corresponds to the type of when_to_save_array, which is typically an array or range of integers.\n\nFields\n\nsave::Bool: A boolean flag to enable (true) or disable (false) the saving of simulation data. Defaults to true.\nfilename::String: The name of the file where simulation data will be saved. Defaults to a randomly generated HDF5 filename (e.g., \"dump_12345.h5\").\nwhen_to_save_array::A: An array or range specifying the simulation steps at which data should be saved. A is the type of this field, typically AbstractArray. Defaults to saving every 1000 steps up to 1,000,000.\nsave_r::Bool: A boolean flag indicating whether to save particle positions (true) or not (false). Defaults to true.\nsave_F::Bool: A boolean flag indicating whether to save particle forces (true) or not (false). Defaults to false.\nsave_Epot::Bool: A boolean flag indicating whether to save the total potential energy of the system (true) or not (false). Defaults to false.\n\n\n\n\n\n","category":"type"},{"location":"api/#SelfPropelledVoronoi.Output","page":"API Reference","title":"SelfPropelledVoronoi.Output","text":"Output()\n\nA mutable struct that stores various simulation output quantities. These quantities are typically updated throughout the simulation and can be used for monitoring progress, logging, or analysis.\n\nFields\n\npotential_energy::Float64: The total potential energy of the system at the current state.\nsteps_done::Int64: The number of simulation time steps that have been completed.\nN_voronoi_tesselations::Int64: The total number of Voronoi tesselations that have been performed during the simulation.\n\n\n\n\n\n","category":"type"},{"location":"api/#SelfPropelledVoronoi.ParameterStruct","page":"API Reference","title":"SelfPropelledVoronoi.ParameterStruct","text":"ParameterStruct(N =100, dt = 0.01, N_steps = 10000, kBT = 1.0, frictionconstant = 1.0,\n                periodic_boundary_layer_depth = 1.0, verbose = false, box = SimulationBox(10.0, 10.0),\n                particles = VoronoiCells(zeros(Float64, 100), zeros(Float64, 100), zeros(Float64, 100),\n                                          zeros(Float64, 100), ones(Float64, 100), ones(Float64, 100)),\n                dump_info = DumpInfo(), callback = x -> nothing,\n                RNG = Random.MersenneTwister(1234))\n\nA struct that holds all essential parameters for running a simulation. This includes physical parameters, numerical parameters, and settings for I/O and control.\n\nType parameters:\n\nP: The type of the particle properties structure (e.g., VoronoiCells), which must be a subtype of Particles.\nCB: The type of the callback function.\n\nFields\n\nN::Int: The total number of particles in the simulation.\ndt::Float64: The time step size for the integration algorithm.\nN_steps::Int: The total number of simulation steps to perform.\nkBT::Float64: The thermal energy, given by the product of Boltzmann's constant (kB) and temperature (T).\nfrictionconstant::Float64: The friction coefficient, determining the damping of particle motion.\nperiodic_boundary_layer_depth::Float64: The depth of the layer around the simulation box used for periodic boundary condition checks and neighbor finding.\nverbose::Bool: A boolean flag to enable (true) or disable (false) verbose output during the simulation.\nbox::SimulationBox: A SimulationBox struct defining the dimensions and properties of the simulation domain.\nparticles::P: A struct (of type P) holding the specific properties of the particles (e.g., VoronoiCells which includes target areas, perimeters, etc.).\ndump_info::DumpInfo: A DumpInfo struct containing parameters for controlling how simulation data is saved to files.\ncallback::CB: A callback function (of type CB) that can be executed at specified intervals during the simulation (e.g., for custom analysis or logging).\nRNG::Random.MersenneTwister: An instance of a random number generator (specifically MersenneTwister) used for stochastic processes in the simulation.\n\n\n\n\n\n","category":"type"},{"location":"api/#SelfPropelledVoronoi.SimulationBox","page":"API Reference","title":"SelfPropelledVoronoi.SimulationBox","text":"SimulationBox(Lx, Ly)\n\nDefines the simulation domain, typically a rectangular box with periodic boundary conditions.\n\nFields\n\nbox_sizes::SVector{2, Float64}: A 2D static vector representing the dimensions (Lx, Ly) of the simulation box. Lx is the width and Ly is the height.\n\n\n\n\n\n","category":"type"},{"location":"api/#SelfPropelledVoronoi.VoronoiCells","page":"API Reference","title":"SelfPropelledVoronoi.VoronoiCells","text":"VoronoiCells(target_perimeters, target_areas, K_P, K_A, active_force_strengths, rotational_diffusion_constants)\n\nRepresents the properties of particles modeled as Voronoi cells. This struct stores parameters related to the mechanical properties (target area and perimeter, and associated spring constants) and active behavior (active force strength and rotational diffusion) of each particle/cell.\n\nFields\n\ntarget_perimeters::Vector{Float64}: Target perimeters for each Voronoi cell. Deviations from these values incur an energy penalty.\ntarget_areas::Vector{Float64}: Target areas for each Voronoi cell. Deviations from these values incur an energy penalty.\nK_P::Vector{Float64}: Spring constants for perimeter deviations. Determines how strongly a cell resists changes to its perimeter.\nK_A::Vector{Float64}: Spring constants for area deviations. Determines how strongly a cell resists changes to its area.\nactive_force_strengths::Vector{Float64}: Magnitudes of the active force for each particle. This force propels the particle in the direction of its orientation.\nrotational_diffusion_constants::Vector{Float64}: Rotational diffusion rates for each particle. This determines how quickly the particle's orientation changes randomly.\n\n\n\n\n\n","category":"type"},{"location":"api/#SelfPropelledVoronoi.VoronoiNeighborList","page":"API Reference","title":"SelfPropelledVoronoi.VoronoiNeighborList","text":"NeighborList\n\nA structure to hold the neighbor list and Voronoi edges for each particle. The neighbors field is a vector of vectors, where each inner vector contains the indices of the neighboring particles for each particle. The voronoi_vertices field is a vector of vectors, where each inner vector contains the index of the Voronoi vertices for each particle. The coordinates are accessed by delauney_circumcenters and are stored in counterclockwise order The delauney_circumcenters field is a vector of vectors, where each inner vector contains the coordinates of the Delauney circumcenters for each particle. The Delauney circumcenters are represented as SVector{2, Float64}.\n\n\n\n\n\n","category":"type"},{"location":"api/#SelfPropelledVoronoi.apply_periodic_boundary_conditions-Tuple{Any, Any}","page":"API Reference","title":"SelfPropelledVoronoi.apply_periodic_boundary_conditions","text":"applyperiodicboundaryconditions(position, boxsizes)\n\nApplies periodic boundary conditions to a given position, ensuring it wraps around the simulation box. For a position coordinate x and a box dimension L, the new coordinate x' is x - floor(x/L) * L. This maps x to the interval [0, L). The same logic applies to all dimensions.\n\nArguments\n\nposition: The original position, typically an SVector or any AbstractVector representing coordinates (e.g., [x, y]).\nbox_sizes: The dimensions of the simulation box, typically an SVector or AbstractVector (e.g., [Lx, Ly]).\n\nReturns\n\nnew_position: The position after applying periodic boundary conditions, of the same type as position.\n\n\n\n\n\n","category":"method"},{"location":"api/#SelfPropelledVoronoi.circumcenter-Union{Tuple{T}, Tuple{StaticArraysCore.SVector{2, T}, StaticArraysCore.SVector{2, T}, StaticArraysCore.SVector{2, T}}} where T","page":"API Reference","title":"SelfPropelledVoronoi.circumcenter","text":"circumcenter(a::SVector{2, T}, b::SVector{2, T}, c::SVector{2, T}) where T\n\nCalculates the circumcenter of a triangle defined by three 2D vertices a, b, and c. The circumcenter is the point where the perpendicular bisectors of the triangle's sides intersect, and it is equidistant from all three vertices. This point is also the center of the triangle's circumcircle.\n\nThe calculation is based on a standard formula for the circumcenter's coordinates (ux, uy) derived from the coordinates of the vertices (ax, ay), (bx, by), (cx, cy): D = 2 * (ax * (by - cy) + bx * (cy - ay) + cx * (ay - by)) ux = (1/D) * ((ax^2 + ay^2) * (by - cy) + (bx^2 + by^2) * (cy - ay) + (cx^2 + cy^2) * (ay - by)) uy = (1/D) * ((ax^2 + ay^2) * (cx - bx) + (bx^2 + by^2) * (ax - cx) + (cx^2 + cy^2) * (bx - ax)) This function uses norm2 which computes ax^2 + ay^2 (squared length from origin).\n\nArguments\n\na::SVector{2, T}: The 2D coordinates of the first vertex of the triangle. T is its element type.\nb::SVector{2, T}: The 2D coordinates of the second vertex of the triangle. T is its element type.\nc::SVector{2, T}: The 2D coordinates of the third vertex of the triangle. T is its element type.\n\nReturns\n\nSVector{2, Float64}: The 2D coordinates (ux, uy) of the circumcenter. The coordinates are always returned as Float64, regardless of the input type T.\n\nNotes\n\nThe function relies on norm2(v) to calculate the squared magnitude of vectors a, b, and c (from the origin), which are used in the circumcenter formula.\nIf the three points a, b, c are collinear, the denominator D will be zero, leading to Inf or NaN coordinates. This case is not explicitly handled here beyond the standard floating-point behavior.\n\n\n\n\n\n","category":"method"},{"location":"api/#SelfPropelledVoronoi.compute_energy-Tuple{Any, Any, Any}","page":"API Reference","title":"SelfPropelledVoronoi.compute_energy","text":"compute_energy(parameters, arrays, output)\n\nComputes the total potential energy of the system. This energy is typically derived from the deviations of individual Voronoi cell areas and perimeters from their target values, penalized by corresponding spring constants.\n\nThis function first calls update_areas! and update_perimeters! to ensure that the current areas and perimeters in arrays are up-to-date before calculating the energy.\n\nArguments\n\nparameters::ParameterStruct: The main simulation parameter struct. \narrays::ArrayStruct: The struct holding simulation arrays. It's passed to update_areas! and update_perimeters!, which use the current areas and perimeters.\noutput::Output: The simulation output struct. Passed to update_areas! and update_perimeters!.\n\nReturns\n\npotential_energy::Float64: The total calculated potential energy of the system. This is the sum of energy contributions from each cell, where each cell's energy is K_A * (area - target_area)^2 + K_P * (perimeter - target_perimeter)^2.\n\n\n\n\n\n","category":"method"},{"location":"api/#SelfPropelledVoronoi.compute_energy_i-NTuple{4, Any}","page":"API Reference","title":"SelfPropelledVoronoi.compute_energy_i","text":"compute_energy_i(i, parameters, arrays, output)\n\nComputes the potential energy contribution of a single Voronoi cell indexed by i. This function calculates the energy based on the deviation of the cell's area and perimeter from their target values, penalized by the corresponding spring constants.\n\nArguments\n\ni::Int: The index of the Voronoi cell for which to compute the energy.\nparameters::ParameterStruct: The main simulation parameter struct. Used to access target areas, target perimeters, and spring constants.\narrays::ArrayStruct: The struct holding simulation arrays. Used to access the current areas and perimeters of the Voronoi cells.\noutput::Output: The simulation output struct. Not directly used in this function but included for consistency in function signatures across the module.\n\nReturns\n\nE::Float64: The computed energy for the Voronoi cell indexed by i. This is calculated as:\n\nKA[i] * (areas[i] - targetareas[i])^2 + KP[i] * (perimeters[i] - targetperimeters[i])^2\n\n\n\n\n\n","category":"method"},{"location":"api/#SelfPropelledVoronoi.compute_forces_GCM!-Tuple{Any, Any, Any}","page":"API Reference","title":"SelfPropelledVoronoi.compute_forces_GCM!","text":"compute_forces_GCM!(parameters, arrays, output)\n\nComputes the forces on each particle using a Gaussian Core Model (GCM). The GCM is a soft, repulsive pair potential where the force between two particles i and j is given by F_ij = -2 * r_ij * exp(-r_ij^2), where r_ij is the distance vector between them. This function calculates the net force on each particle by summing these pairwise forces. Periodic boundary conditions are handled using compute_pair_distance_vector.\n\nThis function might serve as an alternative or simpler test case for force calculations compared to the more complex SPV model.\n\nArguments\n\nparameters::ParameterStruct: The main simulation parameter struct. It provides:\nparameters.N: The number of particles.\nparameters.box.box_sizes: Dimensions of the simulation box, used by compute_pair_distance_vector.\narrays::ArrayStruct: The struct holding simulation arrays.\narrays.positions: A vector of SVector{2, Float64} representing the current positions of all particles.\narrays.forces: A vector of SVector{2, Float64} where the computed force for each particle will be stored. This array is modified in-place.\noutput::Output: The simulation output struct. Not directly used in this function but included for consistency in function signatures.\n\nNotes\n\nThe function modifies arrays.forces in-place with the newly computed forces.\nThe interaction is considered only if the distance r is less than 2^(1/6) (a common cutoff for this potential, related to its inflection point).\n\n\n\n\n\n","category":"method"},{"location":"api/#SelfPropelledVoronoi.compute_forces_SPV!-Tuple{Any, Any, Any}","page":"API Reference","title":"SelfPropelledVoronoi.compute_forces_SPV!","text":"compute_forces_SPV!(parameters, arrays, output)\n\nComputes the forces on each particle based on the Self-Propelled Voronoi (SPV) model. The forces arise from deviations of cell areas and perimeters from their target values, effectively modeling area and perimeter elasticity.\n\nThe function first ensures the Voronoi tessellation is current by calling verify_tesselation. If the tessellation is not valid, it's updated by voronoi_tesselation! or update_delauney_vertices!. Subsequently, it calls update_perimeters! and update_areas! to ensure these geometric properties are current before force calculation.\n\nThe force on particle i is calculated as the negative gradient of the total potential energy with respect to its position r_i. This involves complex derivatives of cell areas and perimeters with respect to vertex positions, and then of vertex positions with respect to particle positions.\n\nArguments\n\nparameters::ParameterStruct: The main simulation parameter struct. This provides access to:\nparameters.N: Number of particles.\nparameters.particles: Contains target_areas, target_perimeters, K_A (area spring constant), K_P (perimeter spring constant).\narrays::ArrayStruct: The struct holding simulation arrays.\narrays.neighborlist: Used to access Voronoi neighbor information, vertex indices, vertex positions per particle, and positions with periodic boundary conditions.\narrays.areas: Current areas of Voronoi cells (read after being updated by update_areas!).\narrays.perimeters: Current perimeters of Voronoi cells (read after being updated by update_perimeters!).\narrays.forces: A vector of SVector{2, Float64} where the computed force for each particle will be stored. This array is modified in-place.\noutput::Output: The simulation output struct. Passed to helper functions like voronoi_tesselation!, update_perimeters!, etc.\n\nNotes\n\nThe function modifies arrays.forces in-place with the newly computed forces.\nThe calculation involves contributions from the particle's own cell energy (dEi/dri) and from the energy of its neighboring cells (dEj/dri).\nThe mathematical details of the force calculation (derivatives of geometry) can be complex and are implemented within the loops.\n\n\n\n\n\n","category":"method"},{"location":"api/#SelfPropelledVoronoi.compute_pair_distance_vector-Tuple{Any, Any, Any}","page":"API Reference","title":"SelfPropelledVoronoi.compute_pair_distance_vector","text":"compute_pair_distance_vector(p1, p2, box_sizes)\n\nComputes the shortest vector (displacement) from particle p1 to particle p2 in a system with periodic boundary conditions (PBC). This is often referred to as the minimum image convention. For a coordinate difference dx and box dimension L, the PBC-aware difference dx' is dx - round(dx/L) * L.\n\nArguments\n\np1: Position of the first particle (e.g., an SVector or AbstractVector like [x1, y1]).\np2: Position of the second particle (e.g., an SVector or AbstractVector like [x2, y2]).\nbox_sizes: Dimensions of the simulation box (e.g., an SVector or AbstractVector like [Lx, Ly]).\n\nReturns\n\ndelta: The displacement vector from p1 to p2 after applying the minimum image convention due to PBC. This will be of the same type as p1 and p2.\n\n\n\n\n\n","category":"method"},{"location":"api/#SelfPropelledVoronoi.do_time_step-Tuple{Any, Any, Any}","page":"API Reference","title":"SelfPropelledVoronoi.do_time_step","text":"do_time_step(parameters, arrays, output)\n\nAdvances the simulation by a single time step by calling an appropriate integration scheme.\n\nThis function acts as a dispatcher for different integration methods. Currently, it selects:\n\ndo_time_step_Euler_Murayama for the very first step of the simulation (output.steps_done == 0).\ndo_time_step_Euler_Heun! for all subsequent steps.\n\nThis strategy might be used, for example, to ensure proper initialization of \"old\" states required by more complex integrators like Heun's method.\n\nArguments\n\nparameters::ParameterStruct: The main simulation parameter struct, containing settings like dt, particle properties, etc. Passed through to the chosen integrator function.\narrays::ArrayStruct: The struct holding simulation arrays (positions, forces, orientations, etc.). These are modified in-place by the chosen integrator function.\noutput::Output: The simulation output struct. output.steps_done is used to determine which integration scheme to use. It's also passed through to the chosen integrator function.\n\nReturns\n\nThe function itself doesn't return a value but calls one of the integrator functions (do_time_step_Euler_Murayama or do_time_step_Euler_Heun!), which in turn modify arrays (and potentially output) in-place.\n\n\n\n\n\n","category":"method"},{"location":"api/#SelfPropelledVoronoi.do_time_step_Euler_Heun!-Tuple{Any, Any, Any}","page":"API Reference","title":"SelfPropelledVoronoi.do_time_step_Euler_Heun!","text":"do_time_step_Euler_Heun!(parameters, arrays, output)\n\nPerforms a single time step using the Euler-Heun predictor-corrector integration scheme. This method is suitable for stochastic differential equations (SDEs) and offers better stability and accuracy than the simpler Euler-Maruyama method for some systems. It involves predicting a future state and then correcting it using an average of forces/drifts.\n\nThe operational steps are:\n\nCompute forces at current positions: compute_forces_SPV! is called to get forces F(x(t_n)) based on current arrays.positions (state at t_n).\nUpdate orientations: Particle orientations θ(t_n) are updated to θ(t_{n+1}) by adding a stochastic rotational diffusion term. arrays.orientations now stores θ(t_{n+1}). The orientations from the start of the step, θ(t_n), are available in arrays.old_orientations (assuming they were stored from a previous step or initialization).\nPredictor step:\nA predicted position x_tilde(t_{n+1}) is calculated using forces F(x(t_n)) and active forces based on orientations θ(t_n) (from arrays.old_orientations).\narrays.positions are updated to these predicted positions.\nStore current forces: The forces F(x(t_n)) (used in the predictor step) are stored in arrays.old_forces.\nCompute forces at predicted positions: compute_forces_SPV! is called again to calculate forces F(x_tilde(t_{n+1})) based on the predicted arrays.positions. arrays.forces now stores these new forces.\nCorrector step:\nThe final positions x(t_{n+1}) are calculated using an average of the \"old\" forces/orientations and the \"new\" (predicted) forces/orientations.   Specifically, it uses 0.5 * [ (F(x(t_n)) + v_active(θ(t_n))) + (F(x_tilde(t_{n+1})) + v_active(θ(t_{n+1}))) ].\narrays.positions are updated to these corrected positions.\nUpdate \"old\" states: arrays.old_positions are updated with the corrected arrays.positions, and arrays.old_orientations are updated with arrays.orientations (θ(t_{n+1})) to prepare for the next time step.\n\nArguments\n\nparameters::ParameterStruct: The main simulation parameter struct, providing:\ndt::Float64: The time step size.\nfrictionconstant::Float64: Used to calculate mobility (1 / frictionconstant).\nparticles.active_force_strengths::Vector{Float64}: Magnitudes of the active force.\nparticles.rotational_diffusion_constants::Vector{Float64}: Rotational diffusion rates.\nN::Int: The total number of particles.\nbox.box_sizes::SVector{2, Float64}: Dimensions for periodic boundary conditions.\narrays::ArrayStruct: The struct holding simulation arrays. The following are used and modified in-place:\npositions::Vector{SVector{2, Float64}}: Initially x(t_n), then x_tilde(t_{n+1}), then corrected x(t_{n+1}).\nforces::Vector{SVector{2, Float64}}: Initially stores F(x(t_n)), then F(x_tilde(t_{n+1})).\norientations::Vector{Float64}: Updated to θ(t_{n+1}) after rotational diffusion.\nold_positions::Vector{SVector{2, Float64}}: Stores x(t_n) at the start, updated to corrected x(t_{n+1}) at the end.\nold_forces::Vector{SVector{2, Float64}}: Updated to store F(x(t_n)).\nold_orientations::Vector{Float64}: Stores θ(t_n) at the start, updated to θ(t_{n+1}) at the end.\noutput::Output: The simulation output struct. Passed to compute_forces_SPV!.\n\nNotes\n\nAll relevant fields in arrays are modified in-place throughout the function.\nThis scheme aims for better accuracy by averaging drifts over the interval.\n\n\n\n\n\n","category":"method"},{"location":"api/#SelfPropelledVoronoi.do_time_step_Euler_Murayama-Tuple{Any, Any, Any}","page":"API Reference","title":"SelfPropelledVoronoi.do_time_step_Euler_Murayama","text":"do_time_step_Euler_Murayama(parameters, arrays, output)\n\nPerforms a single time step using the Euler-Maruyama integration scheme, suitable for stochastic differential equations (SDEs). This method updates particle positions and orientations considering deterministic forces, active self-propulsion forces, and stochastic rotational diffusion.\n\nThe function first calls compute_forces_SPV! to calculate the current deterministic forces on all particles based on their positions and Voronoi cell properties. Then, it updates orientations by adding a random component scaled by the rotational diffusion constant. Finally, it updates positions based on the sum of deterministic forces and active forces (directed by the orientation at the beginning of the step), scaled by mobility and time step dt. Periodic boundary conditions are applied to the new positions.\n\nAt the end of the step, the old_positions, old_forces, and old_orientations arrays are updated to store the state for potential use in subsequent, more complex integration schemes (though this specific integrator is often used as a simpler baseline or for the first step).\n\nArguments\n\nparameters::ParameterStruct: The main simulation parameter struct, providing:\ndt::Float64: The time step size.\nfrictionconstant::Float64: Used to calculate mobility (1 / frictionconstant).\nparticles.active_force_strengths::Vector{Float64}: Magnitudes of the active force for each particle.\nparticles.rotational_diffusion_constants::Vector{Float64}: Rotational diffusion rates for each particle.\nN::Int: The total number of particles.\nbox.box_sizes::SVector{2, Float64}: Dimensions of the simulation box for periodic boundary conditions.\narrays::ArrayStruct: The struct holding simulation arrays. The following fields are used and modified:\npositions::Vector{SVector{2, Float64}}: Updated in-place with new particle positions.\nforces::Vector{SVector{2, Float64}}: Updated in-place by compute_forces_SPV!.\norientations::Vector{Float64}: Updated in-place with new particle orientations.\nold_positions::Vector{SVector{2, Float64}}: Updated in-place to store the new positions.\nold_forces::Vector{SVector{2, Float64}}: Updated in-place to store the new forces.\nold_orientations::Vector{Float64}: Updated in-place to store the new orientations. (Note: the position update uses orientations from before this step's rotational diffusion for the active force direction).\noutput::Output: The simulation output struct. Passed to compute_forces_SPV!.\n\nNotes\n\nAll relevant fields in arrays (positions, forces, orientations, oldpositions, oldforces, old_orientations) are modified in-place.\n\n\n\n\n\n","category":"method"},{"location":"api/#SelfPropelledVoronoi.norm2-Union{Tuple{StaticArraysCore.SVector{2, T}}, Tuple{T}} where T","page":"API Reference","title":"SelfPropelledVoronoi.norm2","text":"norm2(v::SVector{2, T}) where T\n\nComputes the squared Euclidean norm (also known as squared length or squared magnitude) of a 2D vector v.\n\nFor a vector v = [v1, v2], this is calculated as v1^2 + v2^2. This is often used in computations where the actual distance (square root) is not needed, as it avoids a potentially costly square root operation.\n\nArguments\n\nv::SVector{2, T}: The 2D input vector. T is its element type (e.g., Float64).\n\nReturns\n\n::T: The squared Euclidean norm of the vector v, equal to v[1]^2 + v[2]^2. The return type is the same as the element type of the input vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#SelfPropelledVoronoi.replace_or_push!-Tuple{Any, Any, Any}","page":"API Reference","title":"SelfPropelledVoronoi.replace_or_push!","text":"replace_or_push!(array, value, index)\n\nModifies an array in-place by either replacing an element at a specified index or pushing a new value onto the end of the array.\n\nThe behavior is as follows:\n\nIf index is within the current bounds of the array (i.e., 1 <= index <= length(array)), the element at array[index] is replaced with value.\nIf index is one greater than the current length of the array (i.e., index == length(array) + 1), the value is pushed onto the end of the array using push!.\nIf index is out of these bounds (e.g., less than 1, or greater than length(array) + 1), an ArgumentError is thrown.\n\nArguments\n\narray: The array to be modified. This array is changed in-place.\nvalue: The value to be inserted into the array or pushed onto its end.\nindex::Integer: The index at which to replace the existing element, or the position (equal to length(array) + 1) where the new element should be pushed.\n\nReturns\n\nThe function does not explicitly return a value (nothing is implicitly returned if an ArgumentError is not thrown). The primary effect is the modification of the input array.\n\nThrows\n\nArgumentError: If index is not within the valid range for replacement or pushing (i.e., if index < 1 or index > length(array) + 1).\n\n\n\n\n\n","category":"method"},{"location":"api/#SelfPropelledVoronoi.run_simulation!-NTuple{4, Any}","page":"API Reference","title":"SelfPropelledVoronoi.run_simulation!","text":"run_simulation!(parameters, arrays, output, N_steps)\n\nRuns the main simulation loop for a specified number of time steps.\n\nBefore starting the loop, it performs an initial Voronoi tessellation by calling voronoi_tesselation!(parameters, arrays, output) to ensure the system's geometric properties are up-to-date.\n\nThe main loop then proceeds as follows for each step:\n\nVerbose Output: If parameters.verbose is true and the current step is a multiple of 100, the step number is printed to the console.\nCallback Invocation: The user-provided parameters.callback function is called, passing parameters, arrays, and output. This allows for custom actions or analysis during the simulation.\nTime Step Advancement: do_time_step(parameters, arrays, output) is called to advance the simulation state by one time step, updating particle positions, orientations, and forces.\nData Dumping: If parameters.dump_info.save is true, it checks if the current step is in parameters.dump_info.when_to_save_array. If so, save_simulation_state!(parameters, arrays, output) is called to save the current simulation state.\nStep Counting: The local step counter is incremented, and output.steps_done is updated to reflect the completed step.\nTermination: The loop breaks if step exceeds N_steps.\n\nArguments\n\nparameters::ParameterStruct: The main simulation parameter struct. Key fields used:\nverbose::Bool: Flag to enable/disable verbose output.\ndump_info::DumpInfo: Contains parameters for saving simulation data, including save (flag), when_to_save_array (steps for saving).\ncallback: A user-defined function called at each step.\narrays::ArrayStruct: The struct holding simulation arrays (positions, forces, orientations, etc.). This is modified in-place by the functions called within the loop (e.g., do_time_step, voronoi_tesselation!).\noutput::Output: The simulation output struct.\noutput.steps_done: Used to initialize the local step counter and is updated at each iteration. It is also passed to and modified by functions called within the loop.\nN_steps::Int: The total number of time steps to run the simulation.\n\nNotes\n\nThe arrays and output structs are modified in-place throughout the simulation by the various functions called.\nThe simulation starts from the step number indicated by output.steps_done at the beginning of the function call.\n\n\n\n\n\n","category":"method"},{"location":"api/#SelfPropelledVoronoi.save_simulation_state!-Tuple{ParameterStruct, ArrayStruct, Output}","page":"API Reference","title":"SelfPropelledVoronoi.save_simulation_state!","text":"save_simulation_state!(parameters::ParameterStruct, arrays::ArrayStruct, output::Output)\n\nSaves the current state of the simulation to an HDF5 file.\n\nThe function uses the filename specified in parameters.dump_info.filename. It only supports files with .h5 or .hdf5 extensions.\n\nFile Structure:\n\nIf the HDF5 file does not exist, it will be created, and initial simulation parameters will be saved under the /parameters group. These include:\n\n/parameters/N: Number of particles\n/parameters/dt: Timestep size\n/parameters/kBT: Boltzmann temperature\n/parameters/frictionconstant: Friction constant\n/parameters/box_sizes: Dimensions of the simulation box (SVector)\n/parameters/particles/target_perimeters: Target perimeters for Voronoi cells\n/parameters/particles/target_areas: Target areas for Voronoi cells\n/parameters/particles/K_P: Perimeter stiffness constants\n/parameters/particles/K_A: Area stiffness constants\n/parameters/particles/active_force_strengths: Active force strengths\n/parameters/particles/rotational_diffusion_constants: Rotational diffusion constants\n\nFor both new and existing files, the simulation data for the current step (obtained from output.steps_done) is saved in a new group named after the step number (e.g., /0, /1000, etc.).\n\nEach step group (/<step_number>/) contains the following datasets, depending on the flags in parameters.dump_info:\n\npositions: Vector of SVector{2, Float64} (saved if dump_info.save_r is true)\norientations: Vector{Float64} (saved if dump_info.save_r is true)\nforces: Vector of SVector{2, Float64} (saved if dump_info.save_F is true)\npotential_energy: Float64 (saved if dump_info.save_Epot is true)\nareas: Vector{Float64} (always saved)\nperimeters: Vector{Float64} (always saved)\n\nUsage Example:\n\n# Assuming `params`, `arrs`, `outs` are populated ParameterStruct, ArrayStruct, and Output instances\n# and params.dump_info is configured.\nsave_simulation_state!(params, arrs, outs)\n\nThe function returns nothing.\n\n\n\n\n\n","category":"method"},{"location":"api/#SelfPropelledVoronoi.sort_indices_counter_clockwise-Tuple{Any, Any, Any}","page":"API Reference","title":"SelfPropelledVoronoi.sort_indices_counter_clockwise","text":"sort_indices_counter_clockwise(voronoi_vertex_indices, voronoi_vertices, voronoi_center, Lx, Ly)\n\nSorts the Voronoi vertex indices and their corresponding positions for a specific particle's Voronoi cell in a counter-clockwise (CCW) order around the cell's center.\n\nThe sorting is achieved by calculating the angle of each vertex relative to the voronoi_center (the particle's position) and then sorting based on these angles. The atan(dy, dx) function is used to get angles in the range (-π, π], which naturally provides an ordering for CCW sorting.\n\nArguments\n\nvoronoi_vertex_indices::Vector{Int}: A vector of integer indices pointing to the global voronoi_vertices list. These are the vertices associated with the specific particle's cell before sorting.\nvoronoi_vertices::Vector{SVector{2, Float64}}: The global list containing the 2D positions of all Voronoi vertices in the system. The indices in voronoi_vertex_indices refer to this list.\nvoronoi_center::SVector{2, Float64}: The 2D position of the center of the Voronoi cell, which is the position of the particle itself. This is the reference point for angle calculations.\nLx::Float64: The width of the simulation box. Currently unused in this function.\nLy::Float64: The height of the simulation box. Currently unused in this function.\n\nReturns\n\nTuple{Vector{Int}, Vector{SVector{2, Float64}}}: A tuple containing two new vectors:\nThe sorted voronoi_vertex_indices for the particle's cell, ordered counter-clockwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#SelfPropelledVoronoi.update_areas!-Tuple{Any, Any, Any}","page":"API Reference","title":"SelfPropelledVoronoi.update_areas!","text":"update_areas!(parameters, arrays, output)\n\nCalculates and updates the areas of all Voronoi cells. The area of each cell is computed using the shoelace formula (also known as Gauss's area formula), based on the coordinates of its Voronoi vertices. The results are stored in arrays.areas.\n\nArguments\n\nparameters::ParameterStruct: The main simulation parameter struct. Used here to get N, the number of particles.\narrays::ArrayStruct: The struct holding simulation arrays.\noutput::Output: The simulation output struct. Not directly used in this function but included for consistency in function signatures across the module.\n\nNotes\n\nThis function assumes that the Voronoi vertex positions for each cell are already calculated and available in arrays.neighborlist.voronoi_vertices.\nThe arrays.areas vector is updated in-place with the new area values. The shoelace formula calculates signed area, so the division by 2.0 yields the geometric area assuming a consistent vertex ordering.\n\n\n\n\n\n","category":"method"},{"location":"api/#SelfPropelledVoronoi.update_perimeters!-Tuple{Any, Any, Any}","page":"API Reference","title":"SelfPropelledVoronoi.update_perimeters!","text":"update_perimeters!(parameters, arrays, output)\n\nCalculates and updates the perimeters of all Voronoi cells. The perimeter of each cell is computed by summing the lengths of the segments connecting its Voronoi vertices in sequence. The results are stored in arrays.perimeters.\n\nArguments\n\nparameters::ParameterStruct: The main simulation parameter struct. Used here to get N, the number of particles.\narrays::ArrayStruct: The struct holding simulation arrays. \noutput::Output: The simulation output struct. Not directly used in this function but included for consistency in function signatures across the module.\n\nNotes\n\nThis function assumes that the Voronoi vertex positions for each cell are already calculated and available in arrays.neighborlist.voronoi_vertices.\nThe arrays.perimeters vector is updated in-place with the new perimeter values.\n\n\n\n\n\n","category":"method"},{"location":"api/#SelfPropelledVoronoi.update_positions_with_pbcs!-Tuple{Any, Any, Any}","page":"API Reference","title":"SelfPropelledVoronoi.update_positions_with_pbcs!","text":"update_positions_with_pbcs!(parameters, arrays, output)\n\nCreates an extended list of particle positions that includes the original particles and their periodic images located within a defined boundary layer around the simulation box. This extended list is essential for Voronoi tessellation algorithms to correctly construct Voronoi cells for particles near the boundaries of the periodic domain.\n\nThe function first adds all original particle positions. Then, for each original particle, it checks if it's close to any of the box boundaries (left, right, bottom, top) or corners. If a particle is within pbc_layer_depth of a boundary, its corresponding periodic image(s) across that boundary (or corner) are added to the list.\n\nThe generated list of positions (arrays.neighborlist.positions_with_pbc) and a corresponding list of original particle indices (arrays.neighborlist.position_indices) are stored in the arrays.neighborlist structure.\n\nArguments\n\nparameters::ParameterStruct: The main simulation parameter struct, providing:\narrays::ArrayStruct: The struct holding simulation arrays.\noutput::Output: The simulation output struct. Not directly used in this function but included for consistency in function signatures.\n\nNotes\n\nThe fields arrays.neighborlist.positions_with_pbc and arrays.neighborlist.position_indices are modified in-place.\n\n\n\n\n\n","category":"method"},{"location":"api/#SelfPropelledVoronoi.update_voronoi_vertices!-NTuple{4, Any}","page":"API Reference","title":"SelfPropelledVoronoi.update_voronoi_vertices!","text":"\n\n\n\n","category":"method"},{"location":"api/#SelfPropelledVoronoi.verify_tessellation-Tuple{Any, Any, Any}","page":"API Reference","title":"SelfPropelledVoronoi.verify_tessellation","text":"verify_tesselation(parameters, arrays, output)\n\nVerifies the validity of the Voronoi tessellation by checking if all particles are correctly positioned with respect to the Delaunay facets of the tessellation. This function checks that for each Delaunay facet (triangle) defined by a triplet of particles, the circumcircle of the triangle does not contain any other particle that is not one of the triangle's vertices.\n\nArguments\n\nparameters::ParameterStruct: The main simulation parameter struct, providing the number of particles N.\narrays::ArrayStruct: The struct holding simulation arrays, including positions and neighbor lists.\noutput::Output: The simulation output struct. Not directly used in this function but included for consistency in function signatures.\n\nReturns\n\nBool: Returns true if the tessellation is valid (no violations found), or false if any particle is found within the circumcircle of a Delaunay facet that is not one of its vertices.\n\nNotes\n\nThe function assumes that the Voronoi tessellation has already been computed and that the necessary fields in arrays.neighborlist are populated, including delaunay_facet_triplets, positions_with_pbc, and voronoi_neighbors.\nThe field arrays.neighborlist.positionswithpbc is updated to include periodic boundary conditions.\nIf the flag arrays.neighborlist.check_tesselation is set to false, the function immediately returns false, indicating that tessellation verification is not required or has been disabled.\n\n\n\n\n\n","category":"method"},{"location":"api/#SelfPropelledVoronoi.voronoi_tesselation!-Tuple{Any, Any, Any}","page":"API Reference","title":"SelfPropelledVoronoi.voronoi_tesselation!","text":"voronoi_tesselation!(parameters, arrays, output)\n\nPerforms a full Voronoi tessellation of the system based on current particle positions. This function orchestrates several steps to compute the Voronoi diagram, which is dual to the Delaunay triangulation. The results, including lists of Voronoi neighbors, vertex positions, and topological information, are stored in arrays.neighborlist.\n\nThe process involves:\n\nUpdate Positions with PBC: Calls update_positions_with_pbcs! to generate an extended list of particle positions, including periodic images necessary for correct tessellation across boundaries. This list is stored in arrays.neighborlist.positions_with_pbc.\nDelaunay Triangulation: Computes the Delaunay triangulation of the extended particle positions using Quickhull.delaunay.\nProcess Delaunay Facets: Iterates through each facet (triangle) of the Delaunay triangulation:\nThe three particles forming the triangle are identified as Voronoi neighbors of each other. These are added to arrays.neighborlist.voronoi_neighbors.\nThe circumcenter of the Delaunay triangle is calculated using the circumcenter function. This circumcenter is a Voronoi vertex. It's added to a global list of voronoi_vertices and also to arrays.neighborlist.voronoi_vertex_positions_per_particle for each of the three particles forming the triangle.\nThe index of this new Voronoi vertex is added to arrays.neighborlist.voronoi_vertex_indices for each of the three particles.\nA tuple of the three particle indices forming the triangle (cell centers sharing this Voronoi vertex) is stored in arrays.neighborlist.cell_centers_that_share_a_vertex.\nSort Voronoi Vertices: For each of the original N particles, the collected Voronoi vertices associated with it are sorted in counter-clockwise order around the particle's actual position using sort_indices_counter_clockwise. This ensures a consistent representation of Voronoi cells. The sorted vertex indices and positions replace the unsorted ones in arrays.neighborlist.voronoi_vertex_indices and arrays.neighborlist.voronoi_vertex_positions_per_particle for the original particles.\nStore Results: All computed lists (global Voronoi vertices, neighbors per particle, vertex indices per particle, vertex positions per particle, and cell centers sharing a vertex) are stored in the corresponding fields of arrays.neighborlist.\n\nArguments\n\nparameters::ParameterStruct: The main simulation parameter struct.\narrays::ArrayStruct: The struct holding simulation arrays.\noutput::Output: The simulation output struct. Passed to update_positions_with_pbcs!.\n\nNotes\n\nThis function heavily modifies the arrays.neighborlist structure in-place.\nIt relies on Quickhull.jl for the Delaunay triangulation and helper functions like update_positions_with_pbcs!, circumcenter, and sort_indices_counter_clockwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#SelfPropelledVoronoi.when_to_print_array-Tuple{Any}","page":"API Reference","title":"SelfPropelledVoronoi.when_to_print_array","text":"compute_msd(displacement_array)\n\nreturns [1,2,3,4,5,6,7,8,9,10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 200, etc]     Computes the mean squared displacement (MSD) of particles based on their displacement vectors.     The MSD is a measure of the average squared distance that particles have moved from their initial positions.\n\n\n\n\n\n","category":"method"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The example/test.jl script provides a starting point for understanding how to set up and run a basic simulation. ","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Running the code typically consists of the following steps: initialize a small number of particles, define simulation parameters, and run the simulation for a set number of steps.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Here's a conceptual example of how to use the main module and run a simulation:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Import necessary packages\nusing SelfPropelledVoronoi # The main package for the simulation\nusing StaticArrays # Provides SVector for efficient, statically-sized vectors (used here for 2D positions)\nusing Random # Provides random number generation capabilities, including MersenneTwister\n\n# --- Define Simulation Domain and Particle Count ---\n# N: Number of particles in the simulation\nN = 20 \n# box_Lx: Length of the simulation box in the x-dimension\nbox_Lx = 10.0 \n# box_Ly: Length of the simulation box in the y-dimension\nbox_Ly = 10.0 \n# sim_box: Creates a SimulationBox object to store the dimensions of the 2D simulation domain. \n# This object encapsulates the geometry (Lx, Ly) and implies periodic boundary conditions are used by the simulation logic.\nsim_box = SimulationBox(box_Lx, box_Ly)\n\n# --- Define Particle Properties (VoronoiCells) ---\n# These parameters define the physical characteristics and behavior of the simulated particles, \n# which are modeled as cells in a Voronoi tessellation.\n# Each parameter is an array of length N, allowing for different properties for each particle if needed.\n# The VoronoiCells struct groups these properties.\n\n# p0: Target perimeter for each particle (Voronoi cell). \n# Cells will experience an elastic force resisting deviations from this preferred perimeter.\n# units: length units, consistent with box_Lx, box_Ly.\np0 = 3.8 * ones(N) # 'ones(N)' creates a vector of N elements, all set to 1.0, then scaled by 3.8.\n\n# A0: Target area for each particle (Voronoi cell). \n# Similar to p0, deviations from this preferred area will result in an elastic restoring force.\n# units:  area units (length units squared).\nA0 = 1.0 * ones(N)\n\n# KP: Perimeter spring constant (or stiffness). \n# Determines the strength of the force resisting changes to the cell's perimeter. Higher KP means more resistance.\n# units:  energy / length^2 or force / length.\nKP = 1.0 * ones(N)\n\n# KA: Area spring constant (or stiffness). \n# Determines the strength of the force resisting changes to the cell's area. Higher KA means more resistance.\n# units:  energy / area^2 or force / area.\nKA = 1.0 * ones(N)\n\n# f0: Active force strength (or self-propulsion force magnitude). \n# The magnitude of the intrinsic force that drives each particle's movement. The direction is determined by the orientation of the particle.\n# units:  force units.\nf0 = 1.0 * ones(N)\n\n# Dr: Rotational diffusion rate. \n# Controls the rate at which the orientation of particles changes randomly due to rotational noise.\n# units: radians^2 / time \nDr = 0.1 * ones(N)\n\n# particles: Creates a VoronoiCells object to store the collective properties of all particles.\n# The arguments correspond to target_perimeters, target_areas, K_P, K_A, active_force_strengths, and rotational_diffusion_constants respectively.\nparticles = VoronoiCells(p0, A0, KP, KA, f0, Dr)\n\n# --- Define Simulation Parameters ---\n# params: A ParameterStruct structure holding various global simulation settings and constants.\n# The constructor uses keyword arguments.\nparams = ParameterStruct(\n    # Number of particles (already defined)\n    N = N, \n    # Time step for the numerical integration of equations of motion. \n    # Smaller values generally lead to higher accuracy but increase computation time.\n    # units: time units.\n    dt = 0.001, \n    # Total number of simulation steps to perform. The total simulation time will be dt * N_steps.\n    N_steps = 1000, \n     # Thermal energy, product of Boltzmann constant (kB) and Temperature (T). \n    # This term scales the magnitude of random forces due to thermal fluctuations\n    # units: energy units.\n    kBT = 1.0,\n    # Friction coefficient (gamma). Affects the mobility of the cells (the ratio of the force on the cell and its velocity)\n    frictionconstant = 1.0, \n    # Depth of the layer used for handling interactions across periodic boundaries.\n    # Particles within this distance from a boundary will interact with periodic images of particles \n    # from the opposite side of the simulation box. This value should typically be larger than any interaction cutoffs.\n    # units: length units.\n    periodic_boundary_layer_depth = 2.5, \n    # If true, the simulation prints progress messages, warnings, or other information to the console.\n    verbose = true, \n    # The SimulationBox object defining the domain (defined above).\n    box = sim_box, \n    # The VoronoiCells object defining particle properties (defined above).\n    particles = particles, \n    # A DumpInfo structure for controlling data output (e.g., saving simulation snapshots). \n    # Here, 'save=false' indicates that no data will be written to disk during this example run.\n    # Default DumpInfo settings might otherwise enable saving.\n    dump_info = DumpInfo(save=false), \n    # A user-defined function that is called at the start of every time step during the simulation.\n    # 'p', 'a', 'o' typically refer to the parameters, arrays, and output structs, respectively.\n    # Useful for custom actions like live plotting, on-the-fly analysis, or complex data collection. \n    # Here, it's a no-operation (no-op) function, meaning nothing custom is done during simulation steps.\n    callback = (p,a,o) -> nothing, \n    # Random Number Generator (RNG) instance.\n    # `MersenneTwister` is a widely used pseudo-random number generator known for its good statistical properties.\n    # Initializing it with a specific seed (1234 here) ensures that the sequence of random numbers\n    # generated will be the same every time the simulation is run with this seed. This is crucial for reproducibility.\n    RNG = Random.MersenneTwister(1234) \n)\n\n# --- Initialize Particle Positions and Orientations ---\n# arrays: An ArrayStruct structure to hold the dynamic state variables of particles (e.g., positions, orientations) \n# that change over time during the simulation.\narrays = ArrayStruct(N) \n# Initialize positions and orientations randomly:\nfor i in 1:N\n    # arrays.positions[i]: Stores the 2D position (x, y coordinates) of particle 'i'.\n    # `SVector` (StaticVector) from the `StaticArrays.jl` package is used here. \n    # SVectors are stack-allocated, fixed-size arrays that can provide performance benefits for small vectors \n    # (like 2D or 3D coordinates) due to better memory locality and enabling certain compiler optimizations.\n    # Positions are initialized randomly within the simulation box dimensions (box_Lx, box_Ly),\n    # using the provided RNG from the params struct for reproducibility.\n    arrays.positions[i] = SVector(rand(params.RNG)*box_Lx, rand(params.RNG)*box_Ly)\n    # arrays.orientations[i]: Stores the orientation of particle 'i'. \n    # This is represented as an angle in radians (e.g., from 0 to 2*pi).\n    # The orientation determines the direction of the self-propulsion force f0.\n    # Orientations are initialized randomly between 0 and 2*pi using the provided RNG.\n    arrays.orientations[i] = 2pi * rand(params.RNG)\nend\n\n# --- Initialize Output Structure ---\n# output: An Output structure designed to store summary statistics \n# accumulated during the simulation (e.g., total potential energy, steps completed).\noutput = Output()\n\n# --- Run the Simulation ---\n# run_simulation!: This function executes the main simulation loop.\n# It takes the simulation parameters (params), the initial state of particle arrays (arrays), \n# and the output structure (output) as input.\n# The '!' at the end of the function name is a Julia convention indicating that \n# the function is likely to modify one or more of its arguments in-place. In this case, \n# 'arrays' (particle positions/orientations) will be updated at each step, and \n# 'output' will be populated with simulation results like `steps_done`.\nrun_simulation!(params, arrays, output)\n\n# --- Print Simulation Summary ---\n# After the simulation completes, print a message indicating completion and \n# the total number of steps that were actually performed (which should be stored in output.steps_done).\nprintln(\"Simulation finished. Steps done: $(output.steps_done)\")","category":"page"},{"location":"overview/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"SelfPropelledVoronoi.jl is a Julia package designed for simulating two-dimensional (2D) systems of self-propelled particles with periodic boundary conditions. The central idea is that particle interactions and spatial organization are determined by a dynamic Voronoi tessellation of the simulation domain. Each particle corresponds to a Voronoi cell, and the properties of these cells (like area and perimeter) influence particle behavior.","category":"page"},{"location":"overview/#Core-Mechanics","page":"Overview","title":"Core Mechanics","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"The behavior of particles in SelfPropelledVoronoi.jl is governed by a few key mechanical and kinetic principles:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Voronoi Tessellation: The simulation space is continuously partitioned into Voronoi cells, with each cell uniquely associated with a particle. The geometry of these cells (area, perimeter, number of neighbors) determines the forces acting on the cells.\nArea and Perimeter Elasticity:\nEach particle (cell) has a preferred or \"target\" area (A0) and a target perimeter (p0).\nDeviations from these target values result in an elastic energy penalty. For example, if a cell's actual area A is different from A0, there is an energy contribution proportional to KA * (A - A0)^2, where KA is an area stiffness constant. A similar term applies for perimeter deviations with a perimeter stiffness KP.\nThese energy penalties translate into forces that drive the cells to relax towards their target geometries, influencing particle movement and rearrangement.\nActive Particle Motion (Self-Propulsion):\nParticles are \"active,\" meaning they generate their own motion. Each particle i has an intrinsic self-propulsion force of magnitude f0_i.\nThis force is directed along an orientation vector (cos(θ_i), sin(θ_i)), where θ_i is the particle's current orientation angle.\nRotational Diffusion:\nThe orientation θ_i of each particle is not fixed but evolves stochastically over time due to rotational diffusion.\nThis is modeled by adding a random angular displacement at each time step, with the rate of change controlled by a rotational diffusion constant Dr_i.\nPeriodic Boundary Conditions:\nThe simulation is performed in a rectangular domain with periodic boundary conditions. This means that particles exiting one side of the box re-enter from the opposite side, allowing for the simulation of bulk system behavior without edge effects.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"By combining these elements, SelfPropelledVoronoi.jl provides a tool to explore how local interactions and active forces at the particle level give rise to complex, large-scale behaviors in 2D active systems. The reference to Bi et al. (Physical Review X 6.2 (2016): 021011) provides an introduction to this model.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Specifically, it solves the following equations of motion for every particle:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"dmathbfr = left(frac1gamma mathbfF  + v_0 hatmathbfnright)dt","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"in which mathbfr is the particle position, gamma is the friction constant, mathbfF is the potential force mathbfF = - nabla H, v_0 is the active velocity, and hatmathbfn is the direction of the active force that is governed by the angle theta which satisfies a stochastic differential equation:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"dtheta = sqrt2D_rdW","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"in which D_r is the rotational diffusion constant and dW is a Wiener process (standard white noise). The potential force is generated by a Hamiltonian H, which is given by","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"H = sum_i left(K_Ai(A_i-A_0i)^2+K_Pi(P_i-P_0i)^2right)","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"of which the parameters are explained above.","category":"page"},{"location":"#SelfPropelledVoronoi.jl","page":"Home","title":"SelfPropelledVoronoi.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SelfPropelledVoronoi.jl is a Julia package for simulating systems of confluent layers of self-propelled particles. The interactions between these particles are governed by a Voronoi tessellation of the simulation space.","category":"page"},{"location":"#Navigation","page":"Home","title":"Navigation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Overview\nExamples\nAPI Documentation","category":"page"}]
}
